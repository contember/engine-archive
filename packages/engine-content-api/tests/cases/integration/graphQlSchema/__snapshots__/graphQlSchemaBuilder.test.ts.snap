// Vitest Snapshot v1

exports[`GraphQL schema builder > ACL with relations - everything allowed 1`] = `
"type Query {
  getOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, filter: OneHasManyEntityWhere): OneHasManyEntity
  listOneHasManyEntity(filter: OneHasManyEntityWhere, orderBy: [OneHasManyEntityOrderBy!], offset: Int, limit: Int): [OneHasManyEntity!]!
  paginateOneHasManyEntity(filter: OneHasManyEntityWhere, orderBy: [OneHasManyEntityOrderBy!], skip: Int, first: Int): OneHasManyEntityConnection!
  validateCreateOneHasManyEntity(data: OneHasManyEntityCreateInput!): _ValidationResult!
  validateUpdateOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, data: OneHasManyEntityUpdateInput!): _ValidationResult!
  getRoot(by: RootUniqueWhere!, filter: RootWhere): Root
  listRoot(filter: RootWhere, orderBy: [RootOrderBy!], offset: Int, limit: Int): [Root!]!
  paginateRoot(filter: RootWhere, orderBy: [RootOrderBy!], skip: Int, first: Int): RootConnection!
  validateCreateRoot(data: RootCreateInput!): _ValidationResult!
  validateUpdateRoot(by: RootUniqueWhere!, data: RootUpdateInput!): _ValidationResult!
  transaction: QueryTransaction
  _info: Info
}

type OneHasManyEntity {
  _meta: OneHasManyEntityMeta
  id: UUID!
  a: String
  r2(filter: RootWhere): Root
}

type OneHasManyEntityMeta {
  id: FieldMeta
  a: FieldMeta
  r2: FieldMeta
}

type FieldMeta {
  readable: Boolean
  updatable: Boolean
}

scalar UUID

type Root {
  _meta: RootMeta
  id: UUID!
  foo: String
  r(filter: OneHasManyEntityWhere, orderBy: [OneHasManyEntityOrderBy!], offset: Int, limit: Int): [OneHasManyEntity!]!
  paginateR(filter: OneHasManyEntityWhere, orderBy: [OneHasManyEntityOrderBy!], skip: Int, first: Int): OneHasManyEntityConnection!
}

type RootMeta {
  id: FieldMeta
  foo: FieldMeta
  r: FieldMeta
}

input OneHasManyEntityWhere {
  id: UUIDCondition
  a: StringCondition
  r2: RootWhere
  and: [OneHasManyEntityWhere]
  or: [OneHasManyEntityWhere]
  not: OneHasManyEntityWhere
}

input UUIDCondition {
  and: [UUIDCondition!]
  or: [UUIDCondition!]
  not: UUIDCondition
  null: Boolean
  isNull: Boolean
  eq: UUID
  notEq: UUID
  in: [UUID!]
  notIn: [UUID!]
  lt: UUID
  lte: UUID
  gt: UUID
  gte: UUID
}

input StringCondition {
  and: [StringCondition!]
  or: [StringCondition!]
  not: StringCondition
  null: Boolean
  isNull: Boolean
  eq: String
  notEq: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  containsCI: String
  startsWithCI: String
  endsWithCI: String
}

input RootWhere {
  id: UUIDCondition
  foo: StringCondition
  r: OneHasManyEntityWhere
  and: [RootWhere]
  or: [RootWhere]
  not: RootWhere
}

input OneHasManyEntityOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  a: OrderDirection
  r2: RootOrderBy
}

enum OrderDirection {
  asc
  desc
  ascNullsFirst
  descNullsLast
}

input RootOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  foo: OrderDirection
}

type OneHasManyEntityConnection {
  pageInfo: PageInfo!
  edges: [OneHasManyEntityEdge!]!
}

type PageInfo {
  totalCount: Int!
}

type OneHasManyEntityEdge {
  node: OneHasManyEntity!
}

input OneHasManyEntityUniqueWhere {
  id: UUID
}

type _ValidationResult {
  valid: Boolean!
  errors: [_ValidationError!]!
}

type _ValidationError {
  path: [_PathFragment!]!
  message: _ValidationMessage!
}

union _PathFragment = _FieldPathFragment | _IndexPathFragment

type _FieldPathFragment {
  field: String!
}

type _IndexPathFragment {
  index: Int!
  alias: String
}

type _ValidationMessage {
  text: String!
}

input OneHasManyEntityCreateInput {
  a: String
  r2: OneHasManyEntityCreateR2EntityRelationInput
  _dummy_field_: Boolean
}

input OneHasManyEntityCreateR2EntityRelationInput {
  connect: RootUniqueWhere
  create: RootWithoutRCreateInput
}

input RootUniqueWhere {
  id: UUID
  r: OneHasManyEntityUniqueWhere
}

input RootWithoutRCreateInput {
  foo: String
  _dummy_field_: Boolean
}

input OneHasManyEntityUpdateInput {
  a: String
  r2: OneHasManyEntityUpdateR2EntityRelationInput
  _dummy_field_: Boolean
}

input OneHasManyEntityUpdateR2EntityRelationInput {
  create: RootWithoutRCreateInput
  update: RootWithoutRUpdateInput
  upsert: OneHasManyEntityUpsertR2RelationInput
  connect: RootUniqueWhere
  disconnect: Boolean
  delete: Boolean
}

input RootWithoutRUpdateInput {
  foo: String
  _dummy_field_: Boolean
}

input OneHasManyEntityUpsertR2RelationInput {
  update: RootWithoutRUpdateInput
  create: RootWithoutRCreateInput
}

type RootConnection {
  pageInfo: PageInfo!
  edges: [RootEdge!]!
}

type RootEdge {
  node: Root!
}

input RootCreateInput {
  foo: String
  r: [RootCreateREntityRelationInput!]
  _dummy_field_: Boolean
}

input RootCreateREntityRelationInput {
  connect: OneHasManyEntityUniqueWhere
  create: OneHasManyEntityWithoutR2CreateInput
  alias: String
}

input OneHasManyEntityWithoutR2CreateInput {
  a: String
  _dummy_field_: Boolean
}

input RootUpdateInput {
  foo: String
  r: [RootUpdateREntityRelationInput!]
  _dummy_field_: Boolean
}

input RootUpdateREntityRelationInput {
  create: OneHasManyEntityWithoutR2CreateInput
  update: RootUpdateRRelationInput
  upsert: RootUpsertRRelationInput
  connect: OneHasManyEntityUniqueWhere
  disconnect: OneHasManyEntityUniqueWhere
  delete: OneHasManyEntityUniqueWhere
  alias: String
}

input RootUpdateRRelationInput {
  by: OneHasManyEntityUniqueWhere
  data: OneHasManyEntityWithoutR2UpdateInput
}

input OneHasManyEntityWithoutR2UpdateInput {
  a: String
  _dummy_field_: Boolean
}

input RootUpsertRRelationInput {
  by: OneHasManyEntityUniqueWhere
  update: OneHasManyEntityWithoutR2UpdateInput
  create: OneHasManyEntityWithoutR2CreateInput
}

type QueryTransaction {
  getOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, filter: OneHasManyEntityWhere): OneHasManyEntity
  listOneHasManyEntity(filter: OneHasManyEntityWhere, orderBy: [OneHasManyEntityOrderBy!], offset: Int, limit: Int): [OneHasManyEntity!]!
  paginateOneHasManyEntity(filter: OneHasManyEntityWhere, orderBy: [OneHasManyEntityOrderBy!], skip: Int, first: Int): OneHasManyEntityConnection!
  validateCreateOneHasManyEntity(data: OneHasManyEntityCreateInput!): _ValidationResult!
  validateUpdateOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, data: OneHasManyEntityUpdateInput!): _ValidationResult!
  getRoot(by: RootUniqueWhere!, filter: RootWhere): Root
  listRoot(filter: RootWhere, orderBy: [RootOrderBy!], offset: Int, limit: Int): [Root!]!
  paginateRoot(filter: RootWhere, orderBy: [RootOrderBy!], skip: Int, first: Int): RootConnection!
  validateCreateRoot(data: RootCreateInput!): _ValidationResult!
  validateUpdateRoot(by: RootUniqueWhere!, data: RootUpdateInput!): _ValidationResult!
}

type Info {
  description: String
}

type Mutation {
  createOneHasManyEntity(data: OneHasManyEntityCreateInput!): OneHasManyEntityCreateResult!
  deleteOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, filter: OneHasManyEntityWhere): OneHasManyEntityDeleteResult!
  updateOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, filter: OneHasManyEntityWhere, data: OneHasManyEntityUpdateInput!): OneHasManyEntityUpdateResult!
  upsertOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, filter: OneHasManyEntityWhere, update: OneHasManyEntityUpdateInput!, create: OneHasManyEntityCreateInput!): OneHasManyEntityUpsertResult!
  createRoot(data: RootCreateInput!): RootCreateResult!
  deleteRoot(by: RootUniqueWhere!, filter: RootWhere): RootDeleteResult!
  updateRoot(by: RootUniqueWhere!, filter: RootWhere, data: RootUpdateInput!): RootUpdateResult!
  upsertRoot(by: RootUniqueWhere!, filter: RootWhere, update: RootUpdateInput!, create: RootCreateInput!): RootUpsertResult!
  transaction(options: MutationTransactionOptions): MutationTransaction!
  query: Query!
}

type OneHasManyEntityCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: OneHasManyEntity
  validation: _ValidationResult!
}

interface MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
}

type _MutationError {
  path: [_PathFragment!]! @deprecated(reason: \\"Use \`paths\`.\\")
  paths: [[_PathFragment!]!]!
  type: _MutationErrorType!
  message: String
}

enum _MutationErrorType {
  NotNullConstraintViolation
  UniqueConstraintViolation
  ForeignKeyConstraintViolation
  NotFoundOrDenied
  NonUniqueWhereInput
  InvalidDataInput
  SqlError
}

type OneHasManyEntityDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: OneHasManyEntity
}

type OneHasManyEntityUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: OneHasManyEntity
  validation: _ValidationResult!
}

type OneHasManyEntityUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: OneHasManyEntity
  validation: _ValidationResult!
}

type RootCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Root
  validation: _ValidationResult!
}

type RootDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Root
}

type RootUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Root
  validation: _ValidationResult!
}

type RootUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Root
  validation: _ValidationResult!
}

type MutationTransaction {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  validation: _ValidationResult!
  createOneHasManyEntity(data: OneHasManyEntityCreateInput!): OneHasManyEntityCreateResult!
  deleteOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, filter: OneHasManyEntityWhere): OneHasManyEntityDeleteResult!
  updateOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, filter: OneHasManyEntityWhere, data: OneHasManyEntityUpdateInput!): OneHasManyEntityUpdateResult!
  upsertOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, filter: OneHasManyEntityWhere, update: OneHasManyEntityUpdateInput!, create: OneHasManyEntityCreateInput!): OneHasManyEntityUpsertResult!
  createRoot(data: RootCreateInput!): RootCreateResult!
  deleteRoot(by: RootUniqueWhere!, filter: RootWhere): RootDeleteResult!
  updateRoot(by: RootUniqueWhere!, filter: RootWhere, data: RootUpdateInput!): RootUpdateResult!
  upsertRoot(by: RootUniqueWhere!, filter: RootWhere, update: RootUpdateInput!, create: RootCreateInput!): RootUpsertResult!
  query: Query
}

input MutationTransactionOptions {
  deferForeignKeyConstraints: Boolean
}
"
`;

exports[`GraphQL schema builder > ACL with relations - restricted create 1`] = `
"type Query {
  getOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, filter: OneHasManyEntityWhere): OneHasManyEntity
  listOneHasManyEntity(filter: OneHasManyEntityWhere, orderBy: [OneHasManyEntityOrderBy!], offset: Int, limit: Int): [OneHasManyEntity!]!
  paginateOneHasManyEntity(filter: OneHasManyEntityWhere, orderBy: [OneHasManyEntityOrderBy!], skip: Int, first: Int): OneHasManyEntityConnection!
  validateUpdateOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, data: OneHasManyEntityUpdateInput!): _ValidationResult!
  getRoot(by: RootUniqueWhere!, filter: RootWhere): Root
  listRoot(filter: RootWhere, orderBy: [RootOrderBy!], offset: Int, limit: Int): [Root!]!
  paginateRoot(filter: RootWhere, orderBy: [RootOrderBy!], skip: Int, first: Int): RootConnection!
  validateUpdateRoot(by: RootUniqueWhere!, data: RootUpdateInput!): _ValidationResult!
  transaction: QueryTransaction
  _info: Info
}

type OneHasManyEntity {
  _meta: OneHasManyEntityMeta
  id: UUID!
  a: String
  r2(filter: RootWhere): Root
}

type OneHasManyEntityMeta {
  id: FieldMeta
  a: FieldMeta
  r2: FieldMeta
}

type FieldMeta {
  readable: Boolean
  updatable: Boolean
}

scalar UUID

type Root {
  _meta: RootMeta
  id: UUID!
  r(filter: OneHasManyEntityWhere, orderBy: [OneHasManyEntityOrderBy!], offset: Int, limit: Int): [OneHasManyEntity!]!
  paginateR(filter: OneHasManyEntityWhere, orderBy: [OneHasManyEntityOrderBy!], skip: Int, first: Int): OneHasManyEntityConnection!
}

type RootMeta {
  id: FieldMeta
  r: FieldMeta
}

input OneHasManyEntityWhere {
  id: UUIDCondition
  a: StringCondition
  r2: RootWhere
  and: [OneHasManyEntityWhere]
  or: [OneHasManyEntityWhere]
  not: OneHasManyEntityWhere
}

input UUIDCondition {
  and: [UUIDCondition!]
  or: [UUIDCondition!]
  not: UUIDCondition
  null: Boolean
  isNull: Boolean
  eq: UUID
  notEq: UUID
  in: [UUID!]
  notIn: [UUID!]
  lt: UUID
  lte: UUID
  gt: UUID
  gte: UUID
}

input StringCondition {
  and: [StringCondition!]
  or: [StringCondition!]
  not: StringCondition
  null: Boolean
  isNull: Boolean
  eq: String
  notEq: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  containsCI: String
  startsWithCI: String
  endsWithCI: String
}

input RootWhere {
  id: UUIDCondition
  r: OneHasManyEntityWhere
  and: [RootWhere]
  or: [RootWhere]
  not: RootWhere
}

input OneHasManyEntityOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  a: OrderDirection
  r2: RootOrderBy
}

enum OrderDirection {
  asc
  desc
  ascNullsFirst
  descNullsLast
}

input RootOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
}

type OneHasManyEntityConnection {
  pageInfo: PageInfo!
  edges: [OneHasManyEntityEdge!]!
}

type PageInfo {
  totalCount: Int!
}

type OneHasManyEntityEdge {
  node: OneHasManyEntity!
}

input OneHasManyEntityUniqueWhere {
  id: UUID
}

type _ValidationResult {
  valid: Boolean!
  errors: [_ValidationError!]!
}

type _ValidationError {
  path: [_PathFragment!]!
  message: _ValidationMessage!
}

union _PathFragment = _FieldPathFragment | _IndexPathFragment

type _FieldPathFragment {
  field: String!
}

type _IndexPathFragment {
  index: Int!
  alias: String
}

type _ValidationMessage {
  text: String!
}

input OneHasManyEntityUpdateInput {
  a: String
  r2: OneHasManyEntityUpdateR2EntityRelationInput
  _dummy_field_: Boolean
}

input OneHasManyEntityUpdateR2EntityRelationInput {
  update: RootWithoutRUpdateInput
  connect: RootUniqueWhere
  disconnect: Boolean
  delete: Boolean
}

input RootWithoutRUpdateInput {
  _dummy_field_: Boolean
}

input RootUniqueWhere {
  id: UUID
  r: OneHasManyEntityUniqueWhere
}

type RootConnection {
  pageInfo: PageInfo!
  edges: [RootEdge!]!
}

type RootEdge {
  node: Root!
}

input RootUpdateInput {
  r: [RootUpdateREntityRelationInput!]
  _dummy_field_: Boolean
}

input RootUpdateREntityRelationInput {
  update: RootUpdateRRelationInput
  connect: OneHasManyEntityUniqueWhere
  disconnect: OneHasManyEntityUniqueWhere
  delete: OneHasManyEntityUniqueWhere
  alias: String
}

input RootUpdateRRelationInput {
  by: OneHasManyEntityUniqueWhere
  data: OneHasManyEntityWithoutR2UpdateInput
}

input OneHasManyEntityWithoutR2UpdateInput {
  a: String
  _dummy_field_: Boolean
}

type QueryTransaction {
  getOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, filter: OneHasManyEntityWhere): OneHasManyEntity
  listOneHasManyEntity(filter: OneHasManyEntityWhere, orderBy: [OneHasManyEntityOrderBy!], offset: Int, limit: Int): [OneHasManyEntity!]!
  paginateOneHasManyEntity(filter: OneHasManyEntityWhere, orderBy: [OneHasManyEntityOrderBy!], skip: Int, first: Int): OneHasManyEntityConnection!
  validateUpdateOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, data: OneHasManyEntityUpdateInput!): _ValidationResult!
  getRoot(by: RootUniqueWhere!, filter: RootWhere): Root
  listRoot(filter: RootWhere, orderBy: [RootOrderBy!], offset: Int, limit: Int): [Root!]!
  paginateRoot(filter: RootWhere, orderBy: [RootOrderBy!], skip: Int, first: Int): RootConnection!
  validateUpdateRoot(by: RootUniqueWhere!, data: RootUpdateInput!): _ValidationResult!
}

type Info {
  description: String
}

type Mutation {
  deleteOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, filter: OneHasManyEntityWhere): OneHasManyEntityDeleteResult!
  updateOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, filter: OneHasManyEntityWhere, data: OneHasManyEntityUpdateInput!): OneHasManyEntityUpdateResult!
  deleteRoot(by: RootUniqueWhere!, filter: RootWhere): RootDeleteResult!
  updateRoot(by: RootUniqueWhere!, filter: RootWhere, data: RootUpdateInput!): RootUpdateResult!
  transaction(options: MutationTransactionOptions): MutationTransaction!
  query: Query!
}

type OneHasManyEntityDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: OneHasManyEntity
}

interface MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
}

type _MutationError {
  path: [_PathFragment!]! @deprecated(reason: \\"Use \`paths\`.\\")
  paths: [[_PathFragment!]!]!
  type: _MutationErrorType!
  message: String
}

enum _MutationErrorType {
  NotNullConstraintViolation
  UniqueConstraintViolation
  ForeignKeyConstraintViolation
  NotFoundOrDenied
  NonUniqueWhereInput
  InvalidDataInput
  SqlError
}

type OneHasManyEntityUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: OneHasManyEntity
  validation: _ValidationResult!
}

type RootDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Root
}

type RootUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Root
  validation: _ValidationResult!
}

type MutationTransaction {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  validation: _ValidationResult!
  deleteOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, filter: OneHasManyEntityWhere): OneHasManyEntityDeleteResult!
  updateOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, filter: OneHasManyEntityWhere, data: OneHasManyEntityUpdateInput!): OneHasManyEntityUpdateResult!
  deleteRoot(by: RootUniqueWhere!, filter: RootWhere): RootDeleteResult!
  updateRoot(by: RootUniqueWhere!, filter: RootWhere, data: RootUpdateInput!): RootUpdateResult!
  query: Query
}

input MutationTransactionOptions {
  deferForeignKeyConstraints: Boolean
}
"
`;

exports[`GraphQL schema builder > ACL with relations - restricted delete 1`] = `
"type Query {
  getOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, filter: OneHasManyEntityWhere): OneHasManyEntity
  listOneHasManyEntity(filter: OneHasManyEntityWhere, orderBy: [OneHasManyEntityOrderBy!], offset: Int, limit: Int): [OneHasManyEntity!]!
  paginateOneHasManyEntity(filter: OneHasManyEntityWhere, orderBy: [OneHasManyEntityOrderBy!], skip: Int, first: Int): OneHasManyEntityConnection!
  validateCreateOneHasManyEntity(data: OneHasManyEntityCreateInput!): _ValidationResult!
  validateUpdateOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, data: OneHasManyEntityUpdateInput!): _ValidationResult!
  getRoot(by: RootUniqueWhere!, filter: RootWhere): Root
  listRoot(filter: RootWhere, orderBy: [RootOrderBy!], offset: Int, limit: Int): [Root!]!
  paginateRoot(filter: RootWhere, orderBy: [RootOrderBy!], skip: Int, first: Int): RootConnection!
  validateCreateRoot(data: RootCreateInput!): _ValidationResult!
  validateUpdateRoot(by: RootUniqueWhere!, data: RootUpdateInput!): _ValidationResult!
  transaction: QueryTransaction
  _info: Info
}

type OneHasManyEntity {
  _meta: OneHasManyEntityMeta
  id: UUID!
  a: String
  r2(filter: RootWhere): Root
}

type OneHasManyEntityMeta {
  id: FieldMeta
  a: FieldMeta
  r2: FieldMeta
}

type FieldMeta {
  readable: Boolean
  updatable: Boolean
}

scalar UUID

type Root {
  _meta: RootMeta
  id: UUID!
  r(filter: OneHasManyEntityWhere, orderBy: [OneHasManyEntityOrderBy!], offset: Int, limit: Int): [OneHasManyEntity!]!
  paginateR(filter: OneHasManyEntityWhere, orderBy: [OneHasManyEntityOrderBy!], skip: Int, first: Int): OneHasManyEntityConnection!
}

type RootMeta {
  id: FieldMeta
  r: FieldMeta
}

input OneHasManyEntityWhere {
  id: UUIDCondition
  a: StringCondition
  r2: RootWhere
  and: [OneHasManyEntityWhere]
  or: [OneHasManyEntityWhere]
  not: OneHasManyEntityWhere
}

input UUIDCondition {
  and: [UUIDCondition!]
  or: [UUIDCondition!]
  not: UUIDCondition
  null: Boolean
  isNull: Boolean
  eq: UUID
  notEq: UUID
  in: [UUID!]
  notIn: [UUID!]
  lt: UUID
  lte: UUID
  gt: UUID
  gte: UUID
}

input StringCondition {
  and: [StringCondition!]
  or: [StringCondition!]
  not: StringCondition
  null: Boolean
  isNull: Boolean
  eq: String
  notEq: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  containsCI: String
  startsWithCI: String
  endsWithCI: String
}

input RootWhere {
  id: UUIDCondition
  r: OneHasManyEntityWhere
  and: [RootWhere]
  or: [RootWhere]
  not: RootWhere
}

input OneHasManyEntityOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  a: OrderDirection
  r2: RootOrderBy
}

enum OrderDirection {
  asc
  desc
  ascNullsFirst
  descNullsLast
}

input RootOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
}

type OneHasManyEntityConnection {
  pageInfo: PageInfo!
  edges: [OneHasManyEntityEdge!]!
}

type PageInfo {
  totalCount: Int!
}

type OneHasManyEntityEdge {
  node: OneHasManyEntity!
}

input OneHasManyEntityUniqueWhere {
  id: UUID
}

type _ValidationResult {
  valid: Boolean!
  errors: [_ValidationError!]!
}

type _ValidationError {
  path: [_PathFragment!]!
  message: _ValidationMessage!
}

union _PathFragment = _FieldPathFragment | _IndexPathFragment

type _FieldPathFragment {
  field: String!
}

type _IndexPathFragment {
  index: Int!
  alias: String
}

type _ValidationMessage {
  text: String!
}

input OneHasManyEntityCreateInput {
  a: String
  r2: OneHasManyEntityCreateR2EntityRelationInput
  _dummy_field_: Boolean
}

input OneHasManyEntityCreateR2EntityRelationInput {
  connect: RootUniqueWhere
  create: RootWithoutRCreateInput
}

input RootUniqueWhere {
  id: UUID
  r: OneHasManyEntityUniqueWhere
}

input RootWithoutRCreateInput {
  _dummy_field_: Boolean
}

input OneHasManyEntityUpdateInput {
  a: String
  r2: OneHasManyEntityUpdateR2EntityRelationInput
  _dummy_field_: Boolean
}

input OneHasManyEntityUpdateR2EntityRelationInput {
  create: RootWithoutRCreateInput
  update: RootWithoutRUpdateInput
  upsert: OneHasManyEntityUpsertR2RelationInput
  connect: RootUniqueWhere
  disconnect: Boolean
  delete: Boolean
}

input RootWithoutRUpdateInput {
  _dummy_field_: Boolean
}

input OneHasManyEntityUpsertR2RelationInput {
  update: RootWithoutRUpdateInput
  create: RootWithoutRCreateInput
}

type RootConnection {
  pageInfo: PageInfo!
  edges: [RootEdge!]!
}

type RootEdge {
  node: Root!
}

input RootCreateInput {
  r: [RootCreateREntityRelationInput!]
  _dummy_field_: Boolean
}

input RootCreateREntityRelationInput {
  connect: OneHasManyEntityUniqueWhere
  create: OneHasManyEntityWithoutR2CreateInput
  alias: String
}

input OneHasManyEntityWithoutR2CreateInput {
  a: String
  _dummy_field_: Boolean
}

input RootUpdateInput {
  r: [RootUpdateREntityRelationInput!]
  _dummy_field_: Boolean
}

input RootUpdateREntityRelationInput {
  create: OneHasManyEntityWithoutR2CreateInput
  update: RootUpdateRRelationInput
  upsert: RootUpsertRRelationInput
  connect: OneHasManyEntityUniqueWhere
  disconnect: OneHasManyEntityUniqueWhere
  alias: String
}

input RootUpdateRRelationInput {
  by: OneHasManyEntityUniqueWhere
  data: OneHasManyEntityWithoutR2UpdateInput
}

input OneHasManyEntityWithoutR2UpdateInput {
  a: String
  _dummy_field_: Boolean
}

input RootUpsertRRelationInput {
  by: OneHasManyEntityUniqueWhere
  update: OneHasManyEntityWithoutR2UpdateInput
  create: OneHasManyEntityWithoutR2CreateInput
}

type QueryTransaction {
  getOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, filter: OneHasManyEntityWhere): OneHasManyEntity
  listOneHasManyEntity(filter: OneHasManyEntityWhere, orderBy: [OneHasManyEntityOrderBy!], offset: Int, limit: Int): [OneHasManyEntity!]!
  paginateOneHasManyEntity(filter: OneHasManyEntityWhere, orderBy: [OneHasManyEntityOrderBy!], skip: Int, first: Int): OneHasManyEntityConnection!
  validateCreateOneHasManyEntity(data: OneHasManyEntityCreateInput!): _ValidationResult!
  validateUpdateOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, data: OneHasManyEntityUpdateInput!): _ValidationResult!
  getRoot(by: RootUniqueWhere!, filter: RootWhere): Root
  listRoot(filter: RootWhere, orderBy: [RootOrderBy!], offset: Int, limit: Int): [Root!]!
  paginateRoot(filter: RootWhere, orderBy: [RootOrderBy!], skip: Int, first: Int): RootConnection!
  validateCreateRoot(data: RootCreateInput!): _ValidationResult!
  validateUpdateRoot(by: RootUniqueWhere!, data: RootUpdateInput!): _ValidationResult!
}

type Info {
  description: String
}

type Mutation {
  createOneHasManyEntity(data: OneHasManyEntityCreateInput!): OneHasManyEntityCreateResult!
  updateOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, filter: OneHasManyEntityWhere, data: OneHasManyEntityUpdateInput!): OneHasManyEntityUpdateResult!
  upsertOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, filter: OneHasManyEntityWhere, update: OneHasManyEntityUpdateInput!, create: OneHasManyEntityCreateInput!): OneHasManyEntityUpsertResult!
  createRoot(data: RootCreateInput!): RootCreateResult!
  deleteRoot(by: RootUniqueWhere!, filter: RootWhere): RootDeleteResult!
  updateRoot(by: RootUniqueWhere!, filter: RootWhere, data: RootUpdateInput!): RootUpdateResult!
  upsertRoot(by: RootUniqueWhere!, filter: RootWhere, update: RootUpdateInput!, create: RootCreateInput!): RootUpsertResult!
  transaction(options: MutationTransactionOptions): MutationTransaction!
  query: Query!
}

type OneHasManyEntityCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: OneHasManyEntity
  validation: _ValidationResult!
}

interface MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
}

type _MutationError {
  path: [_PathFragment!]! @deprecated(reason: \\"Use \`paths\`.\\")
  paths: [[_PathFragment!]!]!
  type: _MutationErrorType!
  message: String
}

enum _MutationErrorType {
  NotNullConstraintViolation
  UniqueConstraintViolation
  ForeignKeyConstraintViolation
  NotFoundOrDenied
  NonUniqueWhereInput
  InvalidDataInput
  SqlError
}

type OneHasManyEntityUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: OneHasManyEntity
  validation: _ValidationResult!
}

type OneHasManyEntityUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: OneHasManyEntity
  validation: _ValidationResult!
}

type RootCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Root
  validation: _ValidationResult!
}

type RootDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Root
}

type RootUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Root
  validation: _ValidationResult!
}

type RootUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Root
  validation: _ValidationResult!
}

type MutationTransaction {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  validation: _ValidationResult!
  createOneHasManyEntity(data: OneHasManyEntityCreateInput!): OneHasManyEntityCreateResult!
  updateOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, filter: OneHasManyEntityWhere, data: OneHasManyEntityUpdateInput!): OneHasManyEntityUpdateResult!
  upsertOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, filter: OneHasManyEntityWhere, update: OneHasManyEntityUpdateInput!, create: OneHasManyEntityCreateInput!): OneHasManyEntityUpsertResult!
  createRoot(data: RootCreateInput!): RootCreateResult!
  deleteRoot(by: RootUniqueWhere!, filter: RootWhere): RootDeleteResult!
  updateRoot(by: RootUniqueWhere!, filter: RootWhere, data: RootUpdateInput!): RootUpdateResult!
  upsertRoot(by: RootUniqueWhere!, filter: RootWhere, update: RootUpdateInput!, create: RootCreateInput!): RootUpsertResult!
  query: Query
}

input MutationTransactionOptions {
  deferForeignKeyConstraints: Boolean
}
"
`;

exports[`GraphQL schema builder > ACL with relations - restricted update 1`] = `
"type Query {
  getOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, filter: OneHasManyEntityWhere): OneHasManyEntity
  listOneHasManyEntity(filter: OneHasManyEntityWhere, orderBy: [OneHasManyEntityOrderBy!], offset: Int, limit: Int): [OneHasManyEntity!]!
  paginateOneHasManyEntity(filter: OneHasManyEntityWhere, orderBy: [OneHasManyEntityOrderBy!], skip: Int, first: Int): OneHasManyEntityConnection!
  validateCreateOneHasManyEntity(data: OneHasManyEntityCreateInput!): _ValidationResult!
  getRoot(by: RootUniqueWhere!, filter: RootWhere): Root
  listRoot(filter: RootWhere, orderBy: [RootOrderBy!], offset: Int, limit: Int): [Root!]!
  paginateRoot(filter: RootWhere, orderBy: [RootOrderBy!], skip: Int, first: Int): RootConnection!
  validateCreateRoot(data: RootCreateInput!): _ValidationResult!
  validateUpdateRoot(by: RootUniqueWhere!, data: RootUpdateInput!): _ValidationResult!
  transaction: QueryTransaction
  _info: Info
}

type OneHasManyEntity {
  _meta: OneHasManyEntityMeta
  id: UUID!
  a: String
  r2(filter: RootWhere): Root
}

type OneHasManyEntityMeta {
  id: FieldMeta
  a: FieldMeta
  r2: FieldMeta
}

type FieldMeta {
  readable: Boolean
  updatable: Boolean
}

scalar UUID

type Root {
  _meta: RootMeta
  id: UUID!
  r(filter: OneHasManyEntityWhere, orderBy: [OneHasManyEntityOrderBy!], offset: Int, limit: Int): [OneHasManyEntity!]!
  paginateR(filter: OneHasManyEntityWhere, orderBy: [OneHasManyEntityOrderBy!], skip: Int, first: Int): OneHasManyEntityConnection!
}

type RootMeta {
  id: FieldMeta
  r: FieldMeta
}

input OneHasManyEntityWhere {
  id: UUIDCondition
  a: StringCondition
  r2: RootWhere
  and: [OneHasManyEntityWhere]
  or: [OneHasManyEntityWhere]
  not: OneHasManyEntityWhere
}

input UUIDCondition {
  and: [UUIDCondition!]
  or: [UUIDCondition!]
  not: UUIDCondition
  null: Boolean
  isNull: Boolean
  eq: UUID
  notEq: UUID
  in: [UUID!]
  notIn: [UUID!]
  lt: UUID
  lte: UUID
  gt: UUID
  gte: UUID
}

input StringCondition {
  and: [StringCondition!]
  or: [StringCondition!]
  not: StringCondition
  null: Boolean
  isNull: Boolean
  eq: String
  notEq: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  containsCI: String
  startsWithCI: String
  endsWithCI: String
}

input RootWhere {
  id: UUIDCondition
  r: OneHasManyEntityWhere
  and: [RootWhere]
  or: [RootWhere]
  not: RootWhere
}

input OneHasManyEntityOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  a: OrderDirection
  r2: RootOrderBy
}

enum OrderDirection {
  asc
  desc
  ascNullsFirst
  descNullsLast
}

input RootOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
}

type OneHasManyEntityConnection {
  pageInfo: PageInfo!
  edges: [OneHasManyEntityEdge!]!
}

type PageInfo {
  totalCount: Int!
}

type OneHasManyEntityEdge {
  node: OneHasManyEntity!
}

input OneHasManyEntityUniqueWhere {
  id: UUID
}

type _ValidationResult {
  valid: Boolean!
  errors: [_ValidationError!]!
}

type _ValidationError {
  path: [_PathFragment!]!
  message: _ValidationMessage!
}

union _PathFragment = _FieldPathFragment | _IndexPathFragment

type _FieldPathFragment {
  field: String!
}

type _IndexPathFragment {
  index: Int!
  alias: String
}

type _ValidationMessage {
  text: String!
}

input OneHasManyEntityCreateInput {
  a: String
  r2: OneHasManyEntityCreateR2EntityRelationInput
  _dummy_field_: Boolean
}

input OneHasManyEntityCreateR2EntityRelationInput {
  connect: RootUniqueWhere
  create: RootWithoutRCreateInput
}

input RootUniqueWhere {
  id: UUID
  r: OneHasManyEntityUniqueWhere
}

input RootWithoutRCreateInput {
  _dummy_field_: Boolean
}

type RootConnection {
  pageInfo: PageInfo!
  edges: [RootEdge!]!
}

type RootEdge {
  node: Root!
}

input RootCreateInput {
  r: [RootCreateREntityRelationInput!]
  _dummy_field_: Boolean
}

input RootCreateREntityRelationInput {
  connect: OneHasManyEntityUniqueWhere
  create: OneHasManyEntityWithoutR2CreateInput
  alias: String
}

input OneHasManyEntityWithoutR2CreateInput {
  a: String
  _dummy_field_: Boolean
}

input RootUpdateInput {
  _dummy_field_: Boolean
}

type QueryTransaction {
  getOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, filter: OneHasManyEntityWhere): OneHasManyEntity
  listOneHasManyEntity(filter: OneHasManyEntityWhere, orderBy: [OneHasManyEntityOrderBy!], offset: Int, limit: Int): [OneHasManyEntity!]!
  paginateOneHasManyEntity(filter: OneHasManyEntityWhere, orderBy: [OneHasManyEntityOrderBy!], skip: Int, first: Int): OneHasManyEntityConnection!
  validateCreateOneHasManyEntity(data: OneHasManyEntityCreateInput!): _ValidationResult!
  getRoot(by: RootUniqueWhere!, filter: RootWhere): Root
  listRoot(filter: RootWhere, orderBy: [RootOrderBy!], offset: Int, limit: Int): [Root!]!
  paginateRoot(filter: RootWhere, orderBy: [RootOrderBy!], skip: Int, first: Int): RootConnection!
  validateCreateRoot(data: RootCreateInput!): _ValidationResult!
  validateUpdateRoot(by: RootUniqueWhere!, data: RootUpdateInput!): _ValidationResult!
}

type Info {
  description: String
}

type Mutation {
  createOneHasManyEntity(data: OneHasManyEntityCreateInput!): OneHasManyEntityCreateResult!
  deleteOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, filter: OneHasManyEntityWhere): OneHasManyEntityDeleteResult!
  createRoot(data: RootCreateInput!): RootCreateResult!
  deleteRoot(by: RootUniqueWhere!, filter: RootWhere): RootDeleteResult!
  updateRoot(by: RootUniqueWhere!, filter: RootWhere, data: RootUpdateInput!): RootUpdateResult!
  upsertRoot(by: RootUniqueWhere!, filter: RootWhere, update: RootUpdateInput!, create: RootCreateInput!): RootUpsertResult!
  transaction(options: MutationTransactionOptions): MutationTransaction!
  query: Query!
}

type OneHasManyEntityCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: OneHasManyEntity
  validation: _ValidationResult!
}

interface MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
}

type _MutationError {
  path: [_PathFragment!]! @deprecated(reason: \\"Use \`paths\`.\\")
  paths: [[_PathFragment!]!]!
  type: _MutationErrorType!
  message: String
}

enum _MutationErrorType {
  NotNullConstraintViolation
  UniqueConstraintViolation
  ForeignKeyConstraintViolation
  NotFoundOrDenied
  NonUniqueWhereInput
  InvalidDataInput
  SqlError
}

type OneHasManyEntityDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: OneHasManyEntity
}

type RootCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Root
  validation: _ValidationResult!
}

type RootDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Root
}

type RootUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Root
  validation: _ValidationResult!
}

type RootUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Root
  validation: _ValidationResult!
}

type MutationTransaction {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  validation: _ValidationResult!
  createOneHasManyEntity(data: OneHasManyEntityCreateInput!): OneHasManyEntityCreateResult!
  deleteOneHasManyEntity(by: OneHasManyEntityUniqueWhere!, filter: OneHasManyEntityWhere): OneHasManyEntityDeleteResult!
  createRoot(data: RootCreateInput!): RootCreateResult!
  deleteRoot(by: RootUniqueWhere!, filter: RootWhere): RootDeleteResult!
  updateRoot(by: RootUniqueWhere!, filter: RootWhere, data: RootUpdateInput!): RootUpdateResult!
  upsertRoot(by: RootUniqueWhere!, filter: RootWhere, update: RootUpdateInput!, create: RootCreateInput!): RootUpsertResult!
  query: Query
}

input MutationTransactionOptions {
  deferForeignKeyConstraints: Boolean
}
"
`;

exports[`GraphQL schema builder > aliased type 1`] = `
"type Query {
  getAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere): Author
  listAuthor(filter: AuthorWhere, orderBy: [AuthorOrderBy!], offset: Int, limit: Int): [Author!]!
  paginateAuthor(filter: AuthorWhere, orderBy: [AuthorOrderBy!], skip: Int, first: Int): AuthorConnection!
  validateCreateAuthor(data: AuthorCreateInput!): _ValidationResult!
  validateUpdateAuthor(by: AuthorUniqueWhere!, data: AuthorUpdateInput!): _ValidationResult!
  transaction: QueryTransaction
  _info: Info
}

type Author {
  _meta: AuthorMeta
  id: UUID!
  name: AuthorName
}

type AuthorMeta {
  id: FieldMeta
  name: FieldMeta
}

type FieldMeta {
  readable: Boolean
  updatable: Boolean
}

scalar UUID

scalar AuthorName

input AuthorUniqueWhere {
  id: UUID
}

input AuthorWhere {
  id: UUIDCondition
  name: AuthorNameCondition
  and: [AuthorWhere]
  or: [AuthorWhere]
  not: AuthorWhere
}

input UUIDCondition {
  and: [UUIDCondition!]
  or: [UUIDCondition!]
  not: UUIDCondition
  null: Boolean
  isNull: Boolean
  eq: UUID
  notEq: UUID
  in: [UUID!]
  notIn: [UUID!]
  lt: UUID
  lte: UUID
  gt: UUID
  gte: UUID
}

input AuthorNameCondition {
  and: [AuthorNameCondition!]
  or: [AuthorNameCondition!]
  not: AuthorNameCondition
  null: Boolean
  isNull: Boolean
  eq: AuthorName
  notEq: AuthorName
  in: [AuthorName!]
  notIn: [AuthorName!]
  lt: AuthorName
  lte: AuthorName
  gt: AuthorName
  gte: AuthorName
}

input AuthorOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  name: OrderDirection
}

enum OrderDirection {
  asc
  desc
  ascNullsFirst
  descNullsLast
}

type AuthorConnection {
  pageInfo: PageInfo!
  edges: [AuthorEdge!]!
}

type PageInfo {
  totalCount: Int!
}

type AuthorEdge {
  node: Author!
}

type _ValidationResult {
  valid: Boolean!
  errors: [_ValidationError!]!
}

type _ValidationError {
  path: [_PathFragment!]!
  message: _ValidationMessage!
}

union _PathFragment = _FieldPathFragment | _IndexPathFragment

type _FieldPathFragment {
  field: String!
}

type _IndexPathFragment {
  index: Int!
  alias: String
}

type _ValidationMessage {
  text: String!
}

input AuthorCreateInput {
  name: AuthorName
  _dummy_field_: Boolean
}

input AuthorUpdateInput {
  name: AuthorName
  _dummy_field_: Boolean
}

type QueryTransaction {
  getAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere): Author
  listAuthor(filter: AuthorWhere, orderBy: [AuthorOrderBy!], offset: Int, limit: Int): [Author!]!
  paginateAuthor(filter: AuthorWhere, orderBy: [AuthorOrderBy!], skip: Int, first: Int): AuthorConnection!
  validateCreateAuthor(data: AuthorCreateInput!): _ValidationResult!
  validateUpdateAuthor(by: AuthorUniqueWhere!, data: AuthorUpdateInput!): _ValidationResult!
}

type Info {
  description: String
}

type Mutation {
  createAuthor(data: AuthorCreateInput!): AuthorCreateResult!
  deleteAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere): AuthorDeleteResult!
  updateAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere, data: AuthorUpdateInput!): AuthorUpdateResult!
  upsertAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere, update: AuthorUpdateInput!, create: AuthorCreateInput!): AuthorUpsertResult!
  transaction(options: MutationTransactionOptions): MutationTransaction!
  query: Query!
}

type AuthorCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Author
  validation: _ValidationResult!
}

interface MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
}

type _MutationError {
  path: [_PathFragment!]! @deprecated(reason: \\"Use \`paths\`.\\")
  paths: [[_PathFragment!]!]!
  type: _MutationErrorType!
  message: String
}

enum _MutationErrorType {
  NotNullConstraintViolation
  UniqueConstraintViolation
  ForeignKeyConstraintViolation
  NotFoundOrDenied
  NonUniqueWhereInput
  InvalidDataInput
  SqlError
}

type AuthorDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Author
}

type AuthorUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Author
  validation: _ValidationResult!
}

type AuthorUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Author
  validation: _ValidationResult!
}

type MutationTransaction {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  validation: _ValidationResult!
  createAuthor(data: AuthorCreateInput!): AuthorCreateResult!
  deleteAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere): AuthorDeleteResult!
  updateAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere, data: AuthorUpdateInput!): AuthorUpdateResult!
  upsertAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere, update: AuthorUpdateInput!, create: AuthorCreateInput!): AuthorUpsertResult!
  query: Query
}

input MutationTransactionOptions {
  deferForeignKeyConstraints: Boolean
}
"
`;

exports[`GraphQL schema builder > allow only create 1`] = `
"type Query {
  validateCreateAuthor(data: AuthorCreateInput!): _ValidationResult!
  validateCreatePost(data: PostCreateInput!): _ValidationResult!
  validateCreatePostLocale(data: PostLocaleCreateInput!): _ValidationResult!
  validateCreateCategory(data: CategoryCreateInput!): _ValidationResult!
  transaction: QueryTransaction
  _info: Info
}

type _ValidationResult {
  valid: Boolean!
  errors: [_ValidationError!]!
}

type _ValidationError {
  path: [_PathFragment!]!
  message: _ValidationMessage!
}

union _PathFragment = _FieldPathFragment | _IndexPathFragment

type _FieldPathFragment {
  field: String!
}

type _IndexPathFragment {
  index: Int!
  alias: String
}

type _ValidationMessage {
  text: String!
}

input AuthorCreateInput {
  name: String
  posts: [AuthorCreatePostsEntityRelationInput!]
  _dummy_field_: Boolean
}

input AuthorCreatePostsEntityRelationInput {
  create: PostWithoutAuthorCreateInput
  alias: String
}

input PostWithoutAuthorCreateInput {
  state: PostState
  publishedAt: DateTime
  categories: [PostCreateCategoriesEntityRelationInput!]
  locales: [PostCreateLocalesEntityRelationInput!]
  _dummy_field_: Boolean
}

enum PostState {
  draft
  forReview
  published
}

scalar DateTime

input PostCreateCategoriesEntityRelationInput {
  create: CategoryWithoutPostsCreateInput
  alias: String
}

input CategoryWithoutPostsCreateInput {
  name: String
  _dummy_field_: Boolean
}

input PostCreateLocalesEntityRelationInput {
  create: PostLocaleWithoutPostCreateInput
  alias: String
}

input PostLocaleWithoutPostCreateInput {
  locale: Locale
  title: String
  _dummy_field_: Boolean
}

enum Locale {
  cs
  en
}

input PostCreateInput {
  state: PostState
  publishedAt: DateTime
  categories: [PostCreateCategoriesEntityRelationInput!]
  author: PostCreateAuthorEntityRelationInput
  locales: [PostCreateLocalesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostCreateAuthorEntityRelationInput {
  create: AuthorWithoutPostsCreateInput
}

input AuthorWithoutPostsCreateInput {
  name: String
  _dummy_field_: Boolean
}

input PostLocaleCreateInput {
  locale: Locale
  title: String
  post: PostLocaleCreatePostEntityRelationInput
  _dummy_field_: Boolean
}

input PostLocaleCreatePostEntityRelationInput {
  create: PostWithoutLocalesCreateInput
}

input PostWithoutLocalesCreateInput {
  state: PostState
  publishedAt: DateTime
  categories: [PostCreateCategoriesEntityRelationInput!]
  author: PostCreateAuthorEntityRelationInput
  _dummy_field_: Boolean
}

input CategoryCreateInput {
  name: String
  posts: [CategoryCreatePostsEntityRelationInput!]
  _dummy_field_: Boolean
}

input CategoryCreatePostsEntityRelationInput {
  create: PostWithoutCategoriesCreateInput
  alias: String
}

input PostWithoutCategoriesCreateInput {
  state: PostState
  publishedAt: DateTime
  author: PostCreateAuthorEntityRelationInput
  locales: [PostCreateLocalesEntityRelationInput!]
  _dummy_field_: Boolean
}

type QueryTransaction {
  validateCreateAuthor(data: AuthorCreateInput!): _ValidationResult!
  validateCreatePost(data: PostCreateInput!): _ValidationResult!
  validateCreatePostLocale(data: PostLocaleCreateInput!): _ValidationResult!
  validateCreateCategory(data: CategoryCreateInput!): _ValidationResult!
}

type Info {
  description: String
}

type Mutation {
  createAuthor(data: AuthorCreateInput!): AuthorCreateResult!
  createPost(data: PostCreateInput!): PostCreateResult!
  createPostLocale(data: PostLocaleCreateInput!): PostLocaleCreateResult!
  createCategory(data: CategoryCreateInput!): CategoryCreateResult!
  transaction(options: MutationTransactionOptions): MutationTransaction!
  query: Query!
}

type AuthorCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  validation: _ValidationResult!
}

interface MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
}

type _MutationError {
  path: [_PathFragment!]! @deprecated(reason: \\"Use \`paths\`.\\")
  paths: [[_PathFragment!]!]!
  type: _MutationErrorType!
  message: String
}

enum _MutationErrorType {
  NotNullConstraintViolation
  UniqueConstraintViolation
  ForeignKeyConstraintViolation
  NotFoundOrDenied
  NonUniqueWhereInput
  InvalidDataInput
  SqlError
}

type PostCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  validation: _ValidationResult!
}

type PostLocaleCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  validation: _ValidationResult!
}

type CategoryCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  validation: _ValidationResult!
}

type MutationTransaction {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  validation: _ValidationResult!
  createAuthor(data: AuthorCreateInput!): AuthorCreateResult!
  createPost(data: PostCreateInput!): PostCreateResult!
  createPostLocale(data: PostLocaleCreateInput!): PostLocaleCreateResult!
  createCategory(data: CategoryCreateInput!): CategoryCreateResult!
  query: Query
}

input MutationTransactionOptions {
  deferForeignKeyConstraints: Boolean
}
"
`;

exports[`GraphQL schema builder > basic schema > xxx 1`] = `
"type Query {
  getAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere): Author
  listAuthor(filter: AuthorWhere, orderBy: [AuthorOrderBy!], offset: Int, limit: Int): [Author!]!
  paginateAuthor(filter: AuthorWhere, orderBy: [AuthorOrderBy!], skip: Int, first: Int): AuthorConnection!
  validateCreateAuthor(data: AuthorCreateInput!): _ValidationResult!
  validateUpdateAuthor(by: AuthorUniqueWhere!, data: AuthorUpdateInput!): _ValidationResult!
  getCategory(by: CategoryUniqueWhere!, filter: CategoryWhere): Category
  listCategory(filter: CategoryWhere, orderBy: [CategoryOrderBy!], offset: Int, limit: Int): [Category!]!
  paginateCategory(filter: CategoryWhere, orderBy: [CategoryOrderBy!], skip: Int, first: Int): CategoryConnection!
  validateCreateCategory(data: CategoryCreateInput!): _ValidationResult!
  validateUpdateCategory(by: CategoryUniqueWhere!, data: CategoryUpdateInput!): _ValidationResult!
  getPostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere): PostLocale
  listPostLocale(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], offset: Int, limit: Int): [PostLocale!]!
  paginatePostLocale(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], skip: Int, first: Int): PostLocaleConnection!
  validateCreatePostLocale(data: PostLocaleCreateInput!): _ValidationResult!
  validateUpdatePostLocale(by: PostLocaleUniqueWhere!, data: PostLocaleUpdateInput!): _ValidationResult!
  getPost(by: PostUniqueWhere!, filter: PostWhere): Post
  listPost(filter: PostWhere, orderBy: [PostOrderBy!], offset: Int, limit: Int): [Post!]!
  paginatePost(filter: PostWhere, orderBy: [PostOrderBy!], skip: Int, first: Int): PostConnection!
  validateCreatePost(data: PostCreateInput!): _ValidationResult!
  validateUpdatePost(by: PostUniqueWhere!, data: PostUpdateInput!): _ValidationResult!
  transaction: QueryTransaction
  _info: Info
}

type Author {
  _meta: AuthorMeta
  id: UUID!
  name: String
  posts(filter: PostWhere, orderBy: [PostOrderBy!], offset: Int, limit: Int): [Post!]!
  postsByLocales(by: AuthorPostsByLocalesUniqueWhere!, filter: PostWhere): Post
  paginatePosts(filter: PostWhere, orderBy: [PostOrderBy!], skip: Int, first: Int): PostConnection!
}

type AuthorMeta {
  id: FieldMeta
  name: FieldMeta
  posts: FieldMeta
}

type FieldMeta {
  readable: Boolean
  updatable: Boolean
}

scalar UUID

type Post {
  _meta: PostMeta
  author(filter: AuthorWhere): Author
  id: UUID!
  publishedAt: DateTime
  locales(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], offset: Int, limit: Int): [PostLocale!]!
  categories(filter: CategoryWhere, orderBy: [CategoryOrderBy!], offset: Int, limit: Int): [Category!]!
  paginateLocales(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], skip: Int, first: Int): PostLocaleConnection!
  paginateCategories(filter: CategoryWhere, orderBy: [CategoryOrderBy!], skip: Int, first: Int): CategoryConnection!
}

type PostMeta {
  author: FieldMeta
  id: FieldMeta
  publishedAt: FieldMeta
  locales: FieldMeta
  categories: FieldMeta
}

input AuthorWhere {
  id: UUIDCondition
  name: StringCondition
  posts: PostWhere
  and: [AuthorWhere]
  or: [AuthorWhere]
  not: AuthorWhere
}

input UUIDCondition {
  and: [UUIDCondition!]
  or: [UUIDCondition!]
  not: UUIDCondition
  null: Boolean
  isNull: Boolean
  eq: UUID
  notEq: UUID
  in: [UUID!]
  notIn: [UUID!]
  lt: UUID
  lte: UUID
  gt: UUID
  gte: UUID
}

input StringCondition {
  and: [StringCondition!]
  or: [StringCondition!]
  not: StringCondition
  null: Boolean
  isNull: Boolean
  eq: String
  notEq: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  containsCI: String
  startsWithCI: String
  endsWithCI: String
}

input PostWhere {
  author: AuthorWhere
  id: UUIDCondition
  publishedAt: DateTimeCondition
  locales: PostLocaleWhere
  categories: CategoryWhere
  and: [PostWhere]
  or: [PostWhere]
  not: PostWhere
}

input DateTimeCondition {
  and: [DateTimeCondition!]
  or: [DateTimeCondition!]
  not: DateTimeCondition
  null: Boolean
  isNull: Boolean
  eq: DateTime
  notEq: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
}

scalar DateTime

input PostLocaleWhere {
  id: UUIDCondition
  title: StringCondition
  Post: PostWhere
  and: [PostLocaleWhere]
  or: [PostLocaleWhere]
  not: PostLocaleWhere
}

input CategoryWhere {
  id: UUIDCondition
  name: StringCondition
  posts: PostWhere
  and: [CategoryWhere]
  or: [CategoryWhere]
  not: CategoryWhere
}

type PostLocale {
  _meta: PostLocaleMeta
  id: UUID!
  title: String
  Post(filter: PostWhere): Post
}

type PostLocaleMeta {
  id: FieldMeta
  title: FieldMeta
  Post: FieldMeta
}

input PostLocaleOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  title: OrderDirection
  Post: PostOrderBy
}

enum OrderDirection {
  asc
  desc
  ascNullsFirst
  descNullsLast
}

input PostOrderBy {
  _random: Boolean
  _randomSeeded: Int
  author: AuthorOrderBy
  id: OrderDirection
  publishedAt: OrderDirection
}

input AuthorOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  name: OrderDirection
}

type Category {
  _meta: CategoryMeta
  id: UUID!
  name: String
  posts(filter: PostWhere, orderBy: [PostOrderBy!], offset: Int, limit: Int): [Post!]!
  paginatePosts(filter: PostWhere, orderBy: [PostOrderBy!], skip: Int, first: Int): PostConnection!
}

type CategoryMeta {
  id: FieldMeta
  name: FieldMeta
  posts: FieldMeta
}

type PostConnection {
  pageInfo: PageInfo!
  edges: [PostEdge!]!
}

type PageInfo {
  totalCount: Int!
}

type PostEdge {
  node: Post!
}

input CategoryOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  name: OrderDirection
}

type PostLocaleConnection {
  pageInfo: PageInfo!
  edges: [PostLocaleEdge!]!
}

type PostLocaleEdge {
  node: PostLocale!
}

type CategoryConnection {
  pageInfo: PageInfo!
  edges: [CategoryEdge!]!
}

type CategoryEdge {
  node: Category!
}

input AuthorPostsByLocalesUniqueWhere {
  locales: PostLocaleUniqueWhere
}

input PostLocaleUniqueWhere {
  id: UUID
}

input AuthorUniqueWhere {
  id: UUID
  posts: PostUniqueWhere
}

input PostUniqueWhere {
  id: UUID
  locales: PostLocaleUniqueWhere
}

type AuthorConnection {
  pageInfo: PageInfo!
  edges: [AuthorEdge!]!
}

type AuthorEdge {
  node: Author!
}

type _ValidationResult {
  valid: Boolean!
  errors: [_ValidationError!]!
}

type _ValidationError {
  path: [_PathFragment!]!
  message: _ValidationMessage!
}

union _PathFragment = _FieldPathFragment | _IndexPathFragment

type _FieldPathFragment {
  field: String!
}

type _IndexPathFragment {
  index: Int!
  alias: String
}

type _ValidationMessage {
  text: String!
}

input AuthorCreateInput {
  name: String
  posts: [AuthorCreatePostsEntityRelationInput!]
  _dummy_field_: Boolean
}

input AuthorCreatePostsEntityRelationInput {
  connect: PostUniqueWhere
  create: PostWithoutAuthorCreateInput
  alias: String
}

input PostWithoutAuthorCreateInput {
  publishedAt: DateTime
  locales: [PostCreateLocalesEntityRelationInput!]
  categories: [PostCreateCategoriesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostCreateLocalesEntityRelationInput {
  connect: PostLocaleUniqueWhere
  create: PostLocaleWithoutPostCreateInput
  alias: String
}

input PostLocaleWithoutPostCreateInput {
  title: String
  _dummy_field_: Boolean
}

input PostCreateCategoriesEntityRelationInput {
  connect: CategoryUniqueWhere
  create: CategoryWithoutPostsCreateInput
  alias: String
}

input CategoryUniqueWhere {
  id: UUID
}

input CategoryWithoutPostsCreateInput {
  name: String
  _dummy_field_: Boolean
}

input AuthorUpdateInput {
  name: String
  posts: [AuthorUpdatePostsEntityRelationInput!]
  _dummy_field_: Boolean
}

input AuthorUpdatePostsEntityRelationInput {
  create: PostWithoutAuthorCreateInput
  update: AuthorUpdatePostsRelationInput
  upsert: AuthorUpsertPostsRelationInput
  connect: PostUniqueWhere
  disconnect: PostUniqueWhere
  delete: PostUniqueWhere
  alias: String
}

input AuthorUpdatePostsRelationInput {
  by: PostUniqueWhere
  data: PostWithoutAuthorUpdateInput
}

input PostWithoutAuthorUpdateInput {
  publishedAt: DateTime
  locales: [PostUpdateLocalesEntityRelationInput!]
  categories: [PostUpdateCategoriesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostUpdateLocalesEntityRelationInput {
  create: PostLocaleWithoutPostCreateInput
  update: PostUpdateLocalesRelationInput
  upsert: PostUpsertLocalesRelationInput
  connect: PostLocaleUniqueWhere
  disconnect: PostLocaleUniqueWhere
  delete: PostLocaleUniqueWhere
  alias: String
}

input PostUpdateLocalesRelationInput {
  by: PostLocaleUniqueWhere
  data: PostLocaleWithoutPostUpdateInput
}

input PostLocaleWithoutPostUpdateInput {
  title: String
  _dummy_field_: Boolean
}

input PostUpsertLocalesRelationInput {
  by: PostLocaleUniqueWhere
  update: PostLocaleWithoutPostUpdateInput
  create: PostLocaleWithoutPostCreateInput
}

input PostUpdateCategoriesEntityRelationInput {
  create: CategoryWithoutPostsCreateInput
  update: PostUpdateCategoriesRelationInput
  upsert: PostUpsertCategoriesRelationInput
  connect: CategoryUniqueWhere
  disconnect: CategoryUniqueWhere
  delete: CategoryUniqueWhere
  alias: String
}

input PostUpdateCategoriesRelationInput {
  by: CategoryUniqueWhere
  data: CategoryWithoutPostsUpdateInput
}

input CategoryWithoutPostsUpdateInput {
  name: String
  _dummy_field_: Boolean
}

input PostUpsertCategoriesRelationInput {
  by: CategoryUniqueWhere
  update: CategoryWithoutPostsUpdateInput
  create: CategoryWithoutPostsCreateInput
}

input AuthorUpsertPostsRelationInput {
  by: PostUniqueWhere
  update: PostWithoutAuthorUpdateInput
  create: PostWithoutAuthorCreateInput
}

input CategoryCreateInput {
  name: String
  posts: [CategoryCreatePostsEntityRelationInput!]
  _dummy_field_: Boolean
}

input CategoryCreatePostsEntityRelationInput {
  connect: PostUniqueWhere
  create: PostWithoutCategoriesCreateInput
  alias: String
}

input PostWithoutCategoriesCreateInput {
  author: PostCreateAuthorEntityRelationInput
  publishedAt: DateTime
  locales: [PostCreateLocalesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostCreateAuthorEntityRelationInput {
  connect: AuthorUniqueWhere
  create: AuthorWithoutPostsCreateInput
}

input AuthorWithoutPostsCreateInput {
  name: String
  _dummy_field_: Boolean
}

input CategoryUpdateInput {
  name: String
  posts: [CategoryUpdatePostsEntityRelationInput!]
  _dummy_field_: Boolean
}

input CategoryUpdatePostsEntityRelationInput {
  create: PostWithoutCategoriesCreateInput
  update: CategoryUpdatePostsRelationInput
  upsert: CategoryUpsertPostsRelationInput
  connect: PostUniqueWhere
  disconnect: PostUniqueWhere
  delete: PostUniqueWhere
  alias: String
}

input CategoryUpdatePostsRelationInput {
  by: PostUniqueWhere
  data: PostWithoutCategoriesUpdateInput
}

input PostWithoutCategoriesUpdateInput {
  author: PostUpdateAuthorEntityRelationInput
  publishedAt: DateTime
  locales: [PostUpdateLocalesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostUpdateAuthorEntityRelationInput {
  create: AuthorWithoutPostsCreateInput
  update: AuthorWithoutPostsUpdateInput
  upsert: PostUpsertAuthorRelationInput
  connect: AuthorUniqueWhere
  disconnect: Boolean
  delete: Boolean
}

input AuthorWithoutPostsUpdateInput {
  name: String
  _dummy_field_: Boolean
}

input PostUpsertAuthorRelationInput {
  update: AuthorWithoutPostsUpdateInput
  create: AuthorWithoutPostsCreateInput
}

input CategoryUpsertPostsRelationInput {
  by: PostUniqueWhere
  update: PostWithoutCategoriesUpdateInput
  create: PostWithoutCategoriesCreateInput
}

input PostLocaleCreateInput {
  title: String
  Post: PostLocaleCreatePostEntityRelationInput
  _dummy_field_: Boolean
}

input PostLocaleCreatePostEntityRelationInput {
  connect: PostUniqueWhere
  create: PostWithoutLocalesCreateInput
}

input PostWithoutLocalesCreateInput {
  author: PostCreateAuthorEntityRelationInput
  publishedAt: DateTime
  categories: [PostCreateCategoriesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostLocaleUpdateInput {
  title: String
  Post: PostLocaleUpdatePostEntityRelationInput
  _dummy_field_: Boolean
}

input PostLocaleUpdatePostEntityRelationInput {
  create: PostWithoutLocalesCreateInput
  update: PostWithoutLocalesUpdateInput
  upsert: PostLocaleUpsertPostRelationInput
  connect: PostUniqueWhere
  disconnect: Boolean
  delete: Boolean
}

input PostWithoutLocalesUpdateInput {
  author: PostUpdateAuthorEntityRelationInput
  publishedAt: DateTime
  categories: [PostUpdateCategoriesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostLocaleUpsertPostRelationInput {
  update: PostWithoutLocalesUpdateInput
  create: PostWithoutLocalesCreateInput
}

input PostCreateInput {
  author: PostCreateAuthorEntityRelationInput
  publishedAt: DateTime
  locales: [PostCreateLocalesEntityRelationInput!]
  categories: [PostCreateCategoriesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostUpdateInput {
  author: PostUpdateAuthorEntityRelationInput
  publishedAt: DateTime
  locales: [PostUpdateLocalesEntityRelationInput!]
  categories: [PostUpdateCategoriesEntityRelationInput!]
  _dummy_field_: Boolean
}

type QueryTransaction {
  getAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere): Author
  listAuthor(filter: AuthorWhere, orderBy: [AuthorOrderBy!], offset: Int, limit: Int): [Author!]!
  paginateAuthor(filter: AuthorWhere, orderBy: [AuthorOrderBy!], skip: Int, first: Int): AuthorConnection!
  validateCreateAuthor(data: AuthorCreateInput!): _ValidationResult!
  validateUpdateAuthor(by: AuthorUniqueWhere!, data: AuthorUpdateInput!): _ValidationResult!
  getCategory(by: CategoryUniqueWhere!, filter: CategoryWhere): Category
  listCategory(filter: CategoryWhere, orderBy: [CategoryOrderBy!], offset: Int, limit: Int): [Category!]!
  paginateCategory(filter: CategoryWhere, orderBy: [CategoryOrderBy!], skip: Int, first: Int): CategoryConnection!
  validateCreateCategory(data: CategoryCreateInput!): _ValidationResult!
  validateUpdateCategory(by: CategoryUniqueWhere!, data: CategoryUpdateInput!): _ValidationResult!
  getPostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere): PostLocale
  listPostLocale(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], offset: Int, limit: Int): [PostLocale!]!
  paginatePostLocale(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], skip: Int, first: Int): PostLocaleConnection!
  validateCreatePostLocale(data: PostLocaleCreateInput!): _ValidationResult!
  validateUpdatePostLocale(by: PostLocaleUniqueWhere!, data: PostLocaleUpdateInput!): _ValidationResult!
  getPost(by: PostUniqueWhere!, filter: PostWhere): Post
  listPost(filter: PostWhere, orderBy: [PostOrderBy!], offset: Int, limit: Int): [Post!]!
  paginatePost(filter: PostWhere, orderBy: [PostOrderBy!], skip: Int, first: Int): PostConnection!
  validateCreatePost(data: PostCreateInput!): _ValidationResult!
  validateUpdatePost(by: PostUniqueWhere!, data: PostUpdateInput!): _ValidationResult!
}

type Info {
  description: String
}

type Mutation {
  createAuthor(data: AuthorCreateInput!): AuthorCreateResult!
  deleteAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere): AuthorDeleteResult!
  updateAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere, data: AuthorUpdateInput!): AuthorUpdateResult!
  upsertAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere, update: AuthorUpdateInput!, create: AuthorCreateInput!): AuthorUpsertResult!
  createCategory(data: CategoryCreateInput!): CategoryCreateResult!
  deleteCategory(by: CategoryUniqueWhere!, filter: CategoryWhere): CategoryDeleteResult!
  updateCategory(by: CategoryUniqueWhere!, filter: CategoryWhere, data: CategoryUpdateInput!): CategoryUpdateResult!
  upsertCategory(by: CategoryUniqueWhere!, filter: CategoryWhere, update: CategoryUpdateInput!, create: CategoryCreateInput!): CategoryUpsertResult!
  createPostLocale(data: PostLocaleCreateInput!): PostLocaleCreateResult!
  deletePostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere): PostLocaleDeleteResult!
  updatePostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere, data: PostLocaleUpdateInput!): PostLocaleUpdateResult!
  upsertPostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere, update: PostLocaleUpdateInput!, create: PostLocaleCreateInput!): PostLocaleUpsertResult!
  createPost(data: PostCreateInput!): PostCreateResult!
  deletePost(by: PostUniqueWhere!, filter: PostWhere): PostDeleteResult!
  updatePost(by: PostUniqueWhere!, filter: PostWhere, data: PostUpdateInput!): PostUpdateResult!
  upsertPost(by: PostUniqueWhere!, filter: PostWhere, update: PostUpdateInput!, create: PostCreateInput!): PostUpsertResult!
  transaction(options: MutationTransactionOptions): MutationTransaction!
  query: Query!
}

type AuthorCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Author
  validation: _ValidationResult!
}

interface MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
}

type _MutationError {
  path: [_PathFragment!]! @deprecated(reason: \\"Use \`paths\`.\\")
  paths: [[_PathFragment!]!]!
  type: _MutationErrorType!
  message: String
}

enum _MutationErrorType {
  NotNullConstraintViolation
  UniqueConstraintViolation
  ForeignKeyConstraintViolation
  NotFoundOrDenied
  NonUniqueWhereInput
  InvalidDataInput
  SqlError
}

type AuthorDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Author
}

type AuthorUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Author
  validation: _ValidationResult!
}

type AuthorUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Author
  validation: _ValidationResult!
}

type CategoryCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Category
  validation: _ValidationResult!
}

type CategoryDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Category
}

type CategoryUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Category
  validation: _ValidationResult!
}

type CategoryUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Category
  validation: _ValidationResult!
}

type PostLocaleCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: PostLocale
  validation: _ValidationResult!
}

type PostLocaleDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: PostLocale
}

type PostLocaleUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: PostLocale
  validation: _ValidationResult!
}

type PostLocaleUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: PostLocale
  validation: _ValidationResult!
}

type PostCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Post
  validation: _ValidationResult!
}

type PostDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Post
}

type PostUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Post
  validation: _ValidationResult!
}

type PostUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Post
  validation: _ValidationResult!
}

type MutationTransaction {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  validation: _ValidationResult!
  createAuthor(data: AuthorCreateInput!): AuthorCreateResult!
  deleteAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere): AuthorDeleteResult!
  updateAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere, data: AuthorUpdateInput!): AuthorUpdateResult!
  upsertAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere, update: AuthorUpdateInput!, create: AuthorCreateInput!): AuthorUpsertResult!
  createCategory(data: CategoryCreateInput!): CategoryCreateResult!
  deleteCategory(by: CategoryUniqueWhere!, filter: CategoryWhere): CategoryDeleteResult!
  updateCategory(by: CategoryUniqueWhere!, filter: CategoryWhere, data: CategoryUpdateInput!): CategoryUpdateResult!
  upsertCategory(by: CategoryUniqueWhere!, filter: CategoryWhere, update: CategoryUpdateInput!, create: CategoryCreateInput!): CategoryUpsertResult!
  createPostLocale(data: PostLocaleCreateInput!): PostLocaleCreateResult!
  deletePostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere): PostLocaleDeleteResult!
  updatePostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere, data: PostLocaleUpdateInput!): PostLocaleUpdateResult!
  upsertPostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere, update: PostLocaleUpdateInput!, create: PostLocaleCreateInput!): PostLocaleUpsertResult!
  createPost(data: PostCreateInput!): PostCreateResult!
  deletePost(by: PostUniqueWhere!, filter: PostWhere): PostDeleteResult!
  updatePost(by: PostUniqueWhere!, filter: PostWhere, data: PostUpdateInput!): PostUpdateResult!
  upsertPost(by: PostUniqueWhere!, filter: PostWhere, update: PostUpdateInput!, create: PostCreateInput!): PostUpsertResult!
  query: Query
}

input MutationTransactionOptions {
  deferForeignKeyConstraints: Boolean
}
"
`;

exports[`GraphQL schema builder > basic schema 1`] = `
"type Query {
  getAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere): Author
  listAuthor(filter: AuthorWhere, orderBy: [AuthorOrderBy!], offset: Int, limit: Int): [Author!]!
  paginateAuthor(filter: AuthorWhere, orderBy: [AuthorOrderBy!], skip: Int, first: Int): AuthorConnection!
  validateCreateAuthor(data: AuthorCreateInput!): _ValidationResult!
  validateUpdateAuthor(by: AuthorUniqueWhere!, data: AuthorUpdateInput!): _ValidationResult!
  getCategory(by: CategoryUniqueWhere!, filter: CategoryWhere): Category
  listCategory(filter: CategoryWhere, orderBy: [CategoryOrderBy!], offset: Int, limit: Int): [Category!]!
  paginateCategory(filter: CategoryWhere, orderBy: [CategoryOrderBy!], skip: Int, first: Int): CategoryConnection!
  validateCreateCategory(data: CategoryCreateInput!): _ValidationResult!
  validateUpdateCategory(by: CategoryUniqueWhere!, data: CategoryUpdateInput!): _ValidationResult!
  getPostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere): PostLocale
  listPostLocale(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], offset: Int, limit: Int): [PostLocale!]!
  paginatePostLocale(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], skip: Int, first: Int): PostLocaleConnection!
  validateCreatePostLocale(data: PostLocaleCreateInput!): _ValidationResult!
  validateUpdatePostLocale(by: PostLocaleUniqueWhere!, data: PostLocaleUpdateInput!): _ValidationResult!
  getPost(by: PostUniqueWhere!, filter: PostWhere): Post
  listPost(filter: PostWhere, orderBy: [PostOrderBy!], offset: Int, limit: Int): [Post!]!
  paginatePost(filter: PostWhere, orderBy: [PostOrderBy!], skip: Int, first: Int): PostConnection!
  validateCreatePost(data: PostCreateInput!): _ValidationResult!
  validateUpdatePost(by: PostUniqueWhere!, data: PostUpdateInput!): _ValidationResult!
  transaction: QueryTransaction
  _info: Info
}

type Author {
  _meta: AuthorMeta
  id: UUID!
  name: String
  posts(filter: PostWhere, orderBy: [PostOrderBy!], offset: Int, limit: Int): [Post!]!
  postsByLocales(by: AuthorPostsByLocalesUniqueWhere!, filter: PostWhere): Post
  paginatePosts(filter: PostWhere, orderBy: [PostOrderBy!], skip: Int, first: Int): PostConnection!
}

type AuthorMeta {
  id: FieldMeta
  name: FieldMeta
  posts: FieldMeta
}

type FieldMeta {
  readable: Boolean
  updatable: Boolean
}

scalar UUID

type Post {
  _meta: PostMeta
  author(filter: AuthorWhere): Author
  id: UUID!
  publishedAt: DateTime
  locales(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], offset: Int, limit: Int): [PostLocale!]!
  categories(filter: CategoryWhere, orderBy: [CategoryOrderBy!], offset: Int, limit: Int): [Category!]!
  paginateLocales(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], skip: Int, first: Int): PostLocaleConnection!
  paginateCategories(filter: CategoryWhere, orderBy: [CategoryOrderBy!], skip: Int, first: Int): CategoryConnection!
}

type PostMeta {
  author: FieldMeta
  id: FieldMeta
  publishedAt: FieldMeta
  locales: FieldMeta
  categories: FieldMeta
}

input AuthorWhere {
  id: UUIDCondition
  name: StringCondition
  posts: PostWhere
  and: [AuthorWhere]
  or: [AuthorWhere]
  not: AuthorWhere
}

input UUIDCondition {
  and: [UUIDCondition!]
  or: [UUIDCondition!]
  not: UUIDCondition
  null: Boolean
  isNull: Boolean
  eq: UUID
  notEq: UUID
  in: [UUID!]
  notIn: [UUID!]
  lt: UUID
  lte: UUID
  gt: UUID
  gte: UUID
}

input StringCondition {
  and: [StringCondition!]
  or: [StringCondition!]
  not: StringCondition
  null: Boolean
  isNull: Boolean
  eq: String
  notEq: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  containsCI: String
  startsWithCI: String
  endsWithCI: String
}

input PostWhere {
  author: AuthorWhere
  id: UUIDCondition
  publishedAt: DateTimeCondition
  locales: PostLocaleWhere
  categories: CategoryWhere
  and: [PostWhere]
  or: [PostWhere]
  not: PostWhere
}

input DateTimeCondition {
  and: [DateTimeCondition!]
  or: [DateTimeCondition!]
  not: DateTimeCondition
  null: Boolean
  isNull: Boolean
  eq: DateTime
  notEq: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
}

scalar DateTime

input PostLocaleWhere {
  id: UUIDCondition
  title: StringCondition
  Post: PostWhere
  and: [PostLocaleWhere]
  or: [PostLocaleWhere]
  not: PostLocaleWhere
}

input CategoryWhere {
  id: UUIDCondition
  name: StringCondition
  posts: PostWhere
  and: [CategoryWhere]
  or: [CategoryWhere]
  not: CategoryWhere
}

type PostLocale {
  _meta: PostLocaleMeta
  id: UUID!
  title: String
  Post(filter: PostWhere): Post
}

type PostLocaleMeta {
  id: FieldMeta
  title: FieldMeta
  Post: FieldMeta
}

input PostLocaleOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  title: OrderDirection
  Post: PostOrderBy
}

enum OrderDirection {
  asc
  desc
  ascNullsFirst
  descNullsLast
}

input PostOrderBy {
  _random: Boolean
  _randomSeeded: Int
  author: AuthorOrderBy
  id: OrderDirection
  publishedAt: OrderDirection
}

input AuthorOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  name: OrderDirection
}

type Category {
  _meta: CategoryMeta
  id: UUID!
  name: String
  posts(filter: PostWhere, orderBy: [PostOrderBy!], offset: Int, limit: Int): [Post!]!
  paginatePosts(filter: PostWhere, orderBy: [PostOrderBy!], skip: Int, first: Int): PostConnection!
}

type CategoryMeta {
  id: FieldMeta
  name: FieldMeta
  posts: FieldMeta
}

type PostConnection {
  pageInfo: PageInfo!
  edges: [PostEdge!]!
}

type PageInfo {
  totalCount: Int!
}

type PostEdge {
  node: Post!
}

input CategoryOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  name: OrderDirection
}

type PostLocaleConnection {
  pageInfo: PageInfo!
  edges: [PostLocaleEdge!]!
}

type PostLocaleEdge {
  node: PostLocale!
}

type CategoryConnection {
  pageInfo: PageInfo!
  edges: [CategoryEdge!]!
}

type CategoryEdge {
  node: Category!
}

input AuthorPostsByLocalesUniqueWhere {
  locales: PostLocaleUniqueWhere
}

input PostLocaleUniqueWhere {
  id: UUID
}

input AuthorUniqueWhere {
  id: UUID
  posts: PostUniqueWhere
}

input PostUniqueWhere {
  id: UUID
  locales: PostLocaleUniqueWhere
}

type AuthorConnection {
  pageInfo: PageInfo!
  edges: [AuthorEdge!]!
}

type AuthorEdge {
  node: Author!
}

type _ValidationResult {
  valid: Boolean!
  errors: [_ValidationError!]!
}

type _ValidationError {
  path: [_PathFragment!]!
  message: _ValidationMessage!
}

union _PathFragment = _FieldPathFragment | _IndexPathFragment

type _FieldPathFragment {
  field: String!
}

type _IndexPathFragment {
  index: Int!
  alias: String
}

type _ValidationMessage {
  text: String!
}

input AuthorCreateInput {
  name: String
  posts: [AuthorCreatePostsEntityRelationInput!]
  _dummy_field_: Boolean
}

input AuthorCreatePostsEntityRelationInput {
  connect: PostUniqueWhere
  create: PostWithoutAuthorCreateInput
  alias: String
}

input PostWithoutAuthorCreateInput {
  publishedAt: DateTime
  locales: [PostCreateLocalesEntityRelationInput!]
  categories: [PostCreateCategoriesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostCreateLocalesEntityRelationInput {
  connect: PostLocaleUniqueWhere
  create: PostLocaleWithoutPostCreateInput
  alias: String
}

input PostLocaleWithoutPostCreateInput {
  title: String
  _dummy_field_: Boolean
}

input PostCreateCategoriesEntityRelationInput {
  connect: CategoryUniqueWhere
  create: CategoryWithoutPostsCreateInput
  alias: String
}

input CategoryUniqueWhere {
  id: UUID
}

input CategoryWithoutPostsCreateInput {
  name: String
  _dummy_field_: Boolean
}

input AuthorUpdateInput {
  name: String
  posts: [AuthorUpdatePostsEntityRelationInput!]
  _dummy_field_: Boolean
}

input AuthorUpdatePostsEntityRelationInput {
  create: PostWithoutAuthorCreateInput
  update: AuthorUpdatePostsRelationInput
  upsert: AuthorUpsertPostsRelationInput
  connect: PostUniqueWhere
  disconnect: PostUniqueWhere
  delete: PostUniqueWhere
  alias: String
}

input AuthorUpdatePostsRelationInput {
  by: PostUniqueWhere
  data: PostWithoutAuthorUpdateInput
}

input PostWithoutAuthorUpdateInput {
  publishedAt: DateTime
  locales: [PostUpdateLocalesEntityRelationInput!]
  categories: [PostUpdateCategoriesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostUpdateLocalesEntityRelationInput {
  create: PostLocaleWithoutPostCreateInput
  update: PostUpdateLocalesRelationInput
  upsert: PostUpsertLocalesRelationInput
  connect: PostLocaleUniqueWhere
  disconnect: PostLocaleUniqueWhere
  delete: PostLocaleUniqueWhere
  alias: String
}

input PostUpdateLocalesRelationInput {
  by: PostLocaleUniqueWhere
  data: PostLocaleWithoutPostUpdateInput
}

input PostLocaleWithoutPostUpdateInput {
  title: String
  _dummy_field_: Boolean
}

input PostUpsertLocalesRelationInput {
  by: PostLocaleUniqueWhere
  update: PostLocaleWithoutPostUpdateInput
  create: PostLocaleWithoutPostCreateInput
}

input PostUpdateCategoriesEntityRelationInput {
  create: CategoryWithoutPostsCreateInput
  update: PostUpdateCategoriesRelationInput
  upsert: PostUpsertCategoriesRelationInput
  connect: CategoryUniqueWhere
  disconnect: CategoryUniqueWhere
  delete: CategoryUniqueWhere
  alias: String
}

input PostUpdateCategoriesRelationInput {
  by: CategoryUniqueWhere
  data: CategoryWithoutPostsUpdateInput
}

input CategoryWithoutPostsUpdateInput {
  name: String
  _dummy_field_: Boolean
}

input PostUpsertCategoriesRelationInput {
  by: CategoryUniqueWhere
  update: CategoryWithoutPostsUpdateInput
  create: CategoryWithoutPostsCreateInput
}

input AuthorUpsertPostsRelationInput {
  by: PostUniqueWhere
  update: PostWithoutAuthorUpdateInput
  create: PostWithoutAuthorCreateInput
}

input CategoryCreateInput {
  name: String
  posts: [CategoryCreatePostsEntityRelationInput!]
  _dummy_field_: Boolean
}

input CategoryCreatePostsEntityRelationInput {
  connect: PostUniqueWhere
  create: PostWithoutCategoriesCreateInput
  alias: String
}

input PostWithoutCategoriesCreateInput {
  author: PostCreateAuthorEntityRelationInput
  publishedAt: DateTime
  locales: [PostCreateLocalesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostCreateAuthorEntityRelationInput {
  connect: AuthorUniqueWhere
  create: AuthorWithoutPostsCreateInput
}

input AuthorWithoutPostsCreateInput {
  name: String
  _dummy_field_: Boolean
}

input CategoryUpdateInput {
  name: String
  posts: [CategoryUpdatePostsEntityRelationInput!]
  _dummy_field_: Boolean
}

input CategoryUpdatePostsEntityRelationInput {
  create: PostWithoutCategoriesCreateInput
  update: CategoryUpdatePostsRelationInput
  upsert: CategoryUpsertPostsRelationInput
  connect: PostUniqueWhere
  disconnect: PostUniqueWhere
  delete: PostUniqueWhere
  alias: String
}

input CategoryUpdatePostsRelationInput {
  by: PostUniqueWhere
  data: PostWithoutCategoriesUpdateInput
}

input PostWithoutCategoriesUpdateInput {
  author: PostUpdateAuthorEntityRelationInput
  publishedAt: DateTime
  locales: [PostUpdateLocalesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostUpdateAuthorEntityRelationInput {
  create: AuthorWithoutPostsCreateInput
  update: AuthorWithoutPostsUpdateInput
  upsert: PostUpsertAuthorRelationInput
  connect: AuthorUniqueWhere
  disconnect: Boolean
  delete: Boolean
}

input AuthorWithoutPostsUpdateInput {
  name: String
  _dummy_field_: Boolean
}

input PostUpsertAuthorRelationInput {
  update: AuthorWithoutPostsUpdateInput
  create: AuthorWithoutPostsCreateInput
}

input CategoryUpsertPostsRelationInput {
  by: PostUniqueWhere
  update: PostWithoutCategoriesUpdateInput
  create: PostWithoutCategoriesCreateInput
}

input PostLocaleCreateInput {
  title: String
  Post: PostLocaleCreatePostEntityRelationInput
  _dummy_field_: Boolean
}

input PostLocaleCreatePostEntityRelationInput {
  connect: PostUniqueWhere
  create: PostWithoutLocalesCreateInput
}

input PostWithoutLocalesCreateInput {
  author: PostCreateAuthorEntityRelationInput
  publishedAt: DateTime
  categories: [PostCreateCategoriesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostLocaleUpdateInput {
  title: String
  Post: PostLocaleUpdatePostEntityRelationInput
  _dummy_field_: Boolean
}

input PostLocaleUpdatePostEntityRelationInput {
  create: PostWithoutLocalesCreateInput
  update: PostWithoutLocalesUpdateInput
  upsert: PostLocaleUpsertPostRelationInput
  connect: PostUniqueWhere
  disconnect: Boolean
  delete: Boolean
}

input PostWithoutLocalesUpdateInput {
  author: PostUpdateAuthorEntityRelationInput
  publishedAt: DateTime
  categories: [PostUpdateCategoriesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostLocaleUpsertPostRelationInput {
  update: PostWithoutLocalesUpdateInput
  create: PostWithoutLocalesCreateInput
}

input PostCreateInput {
  author: PostCreateAuthorEntityRelationInput
  publishedAt: DateTime
  locales: [PostCreateLocalesEntityRelationInput!]
  categories: [PostCreateCategoriesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostUpdateInput {
  author: PostUpdateAuthorEntityRelationInput
  publishedAt: DateTime
  locales: [PostUpdateLocalesEntityRelationInput!]
  categories: [PostUpdateCategoriesEntityRelationInput!]
  _dummy_field_: Boolean
}

type QueryTransaction {
  getAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere): Author
  listAuthor(filter: AuthorWhere, orderBy: [AuthorOrderBy!], offset: Int, limit: Int): [Author!]!
  paginateAuthor(filter: AuthorWhere, orderBy: [AuthorOrderBy!], skip: Int, first: Int): AuthorConnection!
  validateCreateAuthor(data: AuthorCreateInput!): _ValidationResult!
  validateUpdateAuthor(by: AuthorUniqueWhere!, data: AuthorUpdateInput!): _ValidationResult!
  getCategory(by: CategoryUniqueWhere!, filter: CategoryWhere): Category
  listCategory(filter: CategoryWhere, orderBy: [CategoryOrderBy!], offset: Int, limit: Int): [Category!]!
  paginateCategory(filter: CategoryWhere, orderBy: [CategoryOrderBy!], skip: Int, first: Int): CategoryConnection!
  validateCreateCategory(data: CategoryCreateInput!): _ValidationResult!
  validateUpdateCategory(by: CategoryUniqueWhere!, data: CategoryUpdateInput!): _ValidationResult!
  getPostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere): PostLocale
  listPostLocale(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], offset: Int, limit: Int): [PostLocale!]!
  paginatePostLocale(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], skip: Int, first: Int): PostLocaleConnection!
  validateCreatePostLocale(data: PostLocaleCreateInput!): _ValidationResult!
  validateUpdatePostLocale(by: PostLocaleUniqueWhere!, data: PostLocaleUpdateInput!): _ValidationResult!
  getPost(by: PostUniqueWhere!, filter: PostWhere): Post
  listPost(filter: PostWhere, orderBy: [PostOrderBy!], offset: Int, limit: Int): [Post!]!
  paginatePost(filter: PostWhere, orderBy: [PostOrderBy!], skip: Int, first: Int): PostConnection!
  validateCreatePost(data: PostCreateInput!): _ValidationResult!
  validateUpdatePost(by: PostUniqueWhere!, data: PostUpdateInput!): _ValidationResult!
}

type Info {
  description: String
}

type Mutation {
  createAuthor(data: AuthorCreateInput!): AuthorCreateResult!
  deleteAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere): AuthorDeleteResult!
  updateAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere, data: AuthorUpdateInput!): AuthorUpdateResult!
  upsertAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere, update: AuthorUpdateInput!, create: AuthorCreateInput!): AuthorUpsertResult!
  createCategory(data: CategoryCreateInput!): CategoryCreateResult!
  deleteCategory(by: CategoryUniqueWhere!, filter: CategoryWhere): CategoryDeleteResult!
  updateCategory(by: CategoryUniqueWhere!, filter: CategoryWhere, data: CategoryUpdateInput!): CategoryUpdateResult!
  upsertCategory(by: CategoryUniqueWhere!, filter: CategoryWhere, update: CategoryUpdateInput!, create: CategoryCreateInput!): CategoryUpsertResult!
  createPostLocale(data: PostLocaleCreateInput!): PostLocaleCreateResult!
  deletePostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere): PostLocaleDeleteResult!
  updatePostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere, data: PostLocaleUpdateInput!): PostLocaleUpdateResult!
  upsertPostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere, update: PostLocaleUpdateInput!, create: PostLocaleCreateInput!): PostLocaleUpsertResult!
  createPost(data: PostCreateInput!): PostCreateResult!
  deletePost(by: PostUniqueWhere!, filter: PostWhere): PostDeleteResult!
  updatePost(by: PostUniqueWhere!, filter: PostWhere, data: PostUpdateInput!): PostUpdateResult!
  upsertPost(by: PostUniqueWhere!, filter: PostWhere, update: PostUpdateInput!, create: PostCreateInput!): PostUpsertResult!
  transaction(options: MutationTransactionOptions): MutationTransaction!
  query: Query!
}

type AuthorCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Author
  validation: _ValidationResult!
}

interface MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
}

type _MutationError {
  path: [_PathFragment!]! @deprecated(reason: \\"Use \`paths\`.\\")
  paths: [[_PathFragment!]!]!
  type: _MutationErrorType!
  message: String
}

enum _MutationErrorType {
  NotNullConstraintViolation
  UniqueConstraintViolation
  ForeignKeyConstraintViolation
  NotFoundOrDenied
  NonUniqueWhereInput
  InvalidDataInput
  SqlError
}

type AuthorDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Author
}

type AuthorUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Author
  validation: _ValidationResult!
}

type AuthorUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Author
  validation: _ValidationResult!
}

type CategoryCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Category
  validation: _ValidationResult!
}

type CategoryDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Category
}

type CategoryUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Category
  validation: _ValidationResult!
}

type CategoryUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Category
  validation: _ValidationResult!
}

type PostLocaleCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: PostLocale
  validation: _ValidationResult!
}

type PostLocaleDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: PostLocale
}

type PostLocaleUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: PostLocale
  validation: _ValidationResult!
}

type PostLocaleUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: PostLocale
  validation: _ValidationResult!
}

type PostCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Post
  validation: _ValidationResult!
}

type PostDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Post
}

type PostUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Post
  validation: _ValidationResult!
}

type PostUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Post
  validation: _ValidationResult!
}

type MutationTransaction {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  validation: _ValidationResult!
  createAuthor(data: AuthorCreateInput!): AuthorCreateResult!
  deleteAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere): AuthorDeleteResult!
  updateAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere, data: AuthorUpdateInput!): AuthorUpdateResult!
  upsertAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere, update: AuthorUpdateInput!, create: AuthorCreateInput!): AuthorUpsertResult!
  createCategory(data: CategoryCreateInput!): CategoryCreateResult!
  deleteCategory(by: CategoryUniqueWhere!, filter: CategoryWhere): CategoryDeleteResult!
  updateCategory(by: CategoryUniqueWhere!, filter: CategoryWhere, data: CategoryUpdateInput!): CategoryUpdateResult!
  upsertCategory(by: CategoryUniqueWhere!, filter: CategoryWhere, update: CategoryUpdateInput!, create: CategoryCreateInput!): CategoryUpsertResult!
  createPostLocale(data: PostLocaleCreateInput!): PostLocaleCreateResult!
  deletePostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere): PostLocaleDeleteResult!
  updatePostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere, data: PostLocaleUpdateInput!): PostLocaleUpdateResult!
  upsertPostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere, update: PostLocaleUpdateInput!, create: PostLocaleCreateInput!): PostLocaleUpsertResult!
  createPost(data: PostCreateInput!): PostCreateResult!
  deletePost(by: PostUniqueWhere!, filter: PostWhere): PostDeleteResult!
  updatePost(by: PostUniqueWhere!, filter: PostWhere, data: PostUpdateInput!): PostUpdateResult!
  upsertPost(by: PostUniqueWhere!, filter: PostWhere, update: PostUpdateInput!, create: PostCreateInput!): PostUpsertResult!
  query: Query
}

input MutationTransactionOptions {
  deferForeignKeyConstraints: Boolean
}
"
`;

exports[`GraphQL schema builder > basic schema with new builder 1`] = `
"type Query {
  getAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere): Author
  listAuthor(filter: AuthorWhere, orderBy: [AuthorOrderBy!], offset: Int, limit: Int): [Author!]!
  paginateAuthor(filter: AuthorWhere, orderBy: [AuthorOrderBy!], skip: Int, first: Int): AuthorConnection!
  validateCreateAuthor(data: AuthorCreateInput!): _ValidationResult!
  validateUpdateAuthor(by: AuthorUniqueWhere!, data: AuthorUpdateInput!): _ValidationResult!
  getPost(by: PostUniqueWhere!, filter: PostWhere): Post
  listPost(filter: PostWhere, orderBy: [PostOrderBy!], offset: Int, limit: Int): [Post!]!
  paginatePost(filter: PostWhere, orderBy: [PostOrderBy!], skip: Int, first: Int): PostConnection!
  validateCreatePost(data: PostCreateInput!): _ValidationResult!
  validateUpdatePost(by: PostUniqueWhere!, data: PostUpdateInput!): _ValidationResult!
  getPostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere): PostLocale
  listPostLocale(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], offset: Int, limit: Int): [PostLocale!]!
  paginatePostLocale(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], skip: Int, first: Int): PostLocaleConnection!
  validateCreatePostLocale(data: PostLocaleCreateInput!): _ValidationResult!
  validateUpdatePostLocale(by: PostLocaleUniqueWhere!, data: PostLocaleUpdateInput!): _ValidationResult!
  getCategory(by: CategoryUniqueWhere!, filter: CategoryWhere): Category
  listCategory(filter: CategoryWhere, orderBy: [CategoryOrderBy!], offset: Int, limit: Int): [Category!]!
  paginateCategory(filter: CategoryWhere, orderBy: [CategoryOrderBy!], skip: Int, first: Int): CategoryConnection!
  validateCreateCategory(data: CategoryCreateInput!): _ValidationResult!
  validateUpdateCategory(by: CategoryUniqueWhere!, data: CategoryUpdateInput!): _ValidationResult!
  transaction: QueryTransaction
  _info: Info
}

type Author {
  _meta: AuthorMeta
  id: UUID!
  name: String
  posts(filter: PostWhere, orderBy: [PostOrderBy!], offset: Int, limit: Int): [Post!]!
  postsByLocales(by: AuthorPostsByLocalesUniqueWhere!, filter: PostWhere): Post
  paginatePosts(filter: PostWhere, orderBy: [PostOrderBy!], skip: Int, first: Int): PostConnection!
}

type AuthorMeta {
  id: FieldMeta
  name: FieldMeta
  posts: FieldMeta
}

type FieldMeta {
  readable: Boolean
  updatable: Boolean
}

scalar UUID

type Post {
  _meta: PostMeta
  id: UUID!
  state: PostState
  publishedAt: DateTime
  categories(filter: CategoryWhere, orderBy: [CategoryOrderBy!], offset: Int, limit: Int): [Category!]!
  author(filter: AuthorWhere): Author
  locales(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], offset: Int, limit: Int): [PostLocale!]!
  localesByLocale(by: PostLocalesByLocaleUniqueWhere!, filter: PostLocaleWhere): PostLocale
  paginateCategories(filter: CategoryWhere, orderBy: [CategoryOrderBy!], skip: Int, first: Int): CategoryConnection!
  paginateLocales(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], skip: Int, first: Int): PostLocaleConnection!
}

type PostMeta {
  id: FieldMeta
  state: FieldMeta
  publishedAt: FieldMeta
  categories: FieldMeta
  author: FieldMeta
  locales: FieldMeta
}

enum PostState {
  draft
  forReview
  published
}

scalar DateTime

type Category {
  _meta: CategoryMeta
  id: UUID!
  name: String
  posts(filter: PostWhere, orderBy: [PostOrderBy!], offset: Int, limit: Int): [Post!]!
  paginatePosts(filter: PostWhere, orderBy: [PostOrderBy!], skip: Int, first: Int): PostConnection!
}

type CategoryMeta {
  id: FieldMeta
  name: FieldMeta
  posts: FieldMeta
}

input PostWhere {
  id: UUIDCondition
  state: PostStateEnumCondition
  publishedAt: DateTimeCondition
  categories: CategoryWhere
  author: AuthorWhere
  locales: PostLocaleWhere
  and: [PostWhere]
  or: [PostWhere]
  not: PostWhere
}

input UUIDCondition {
  and: [UUIDCondition!]
  or: [UUIDCondition!]
  not: UUIDCondition
  null: Boolean
  isNull: Boolean
  eq: UUID
  notEq: UUID
  in: [UUID!]
  notIn: [UUID!]
  lt: UUID
  lte: UUID
  gt: UUID
  gte: UUID
}

input PostStateEnumCondition {
  and: [PostStateEnumCondition!]
  or: [PostStateEnumCondition!]
  not: PostStateEnumCondition
  null: Boolean
  isNull: Boolean
  eq: PostState
  notEq: PostState
  in: [PostState!]
  notIn: [PostState!]
  lt: PostState
  lte: PostState
  gt: PostState
  gte: PostState
}

input DateTimeCondition {
  and: [DateTimeCondition!]
  or: [DateTimeCondition!]
  not: DateTimeCondition
  null: Boolean
  isNull: Boolean
  eq: DateTime
  notEq: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
}

input CategoryWhere {
  id: UUIDCondition
  name: StringCondition
  posts: PostWhere
  and: [CategoryWhere]
  or: [CategoryWhere]
  not: CategoryWhere
}

input StringCondition {
  and: [StringCondition!]
  or: [StringCondition!]
  not: StringCondition
  null: Boolean
  isNull: Boolean
  eq: String
  notEq: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  containsCI: String
  startsWithCI: String
  endsWithCI: String
}

input AuthorWhere {
  id: UUIDCondition
  name: StringCondition
  posts: PostWhere
  and: [AuthorWhere]
  or: [AuthorWhere]
  not: AuthorWhere
}

input PostLocaleWhere {
  id: UUIDCondition
  locale: LocaleEnumCondition
  title: StringCondition
  post: PostWhere
  and: [PostLocaleWhere]
  or: [PostLocaleWhere]
  not: PostLocaleWhere
}

input LocaleEnumCondition {
  and: [LocaleEnumCondition!]
  or: [LocaleEnumCondition!]
  not: LocaleEnumCondition
  null: Boolean
  isNull: Boolean
  eq: Locale
  notEq: Locale
  in: [Locale!]
  notIn: [Locale!]
  lt: Locale
  lte: Locale
  gt: Locale
  gte: Locale
}

enum Locale {
  cs
  en
}

input PostOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  state: OrderDirection
  publishedAt: OrderDirection
  author: AuthorOrderBy
}

enum OrderDirection {
  asc
  desc
  ascNullsFirst
  descNullsLast
}

input AuthorOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  name: OrderDirection
}

type PostConnection {
  pageInfo: PageInfo!
  edges: [PostEdge!]!
}

type PageInfo {
  totalCount: Int!
}

type PostEdge {
  node: Post!
}

input CategoryOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  name: OrderDirection
}

type PostLocale {
  _meta: PostLocaleMeta
  id: UUID!
  locale: Locale
  title: String
  post(filter: PostWhere): Post
}

type PostLocaleMeta {
  id: FieldMeta
  locale: FieldMeta
  title: FieldMeta
  post: FieldMeta
}

input PostLocaleOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  locale: OrderDirection
  title: OrderDirection
  post: PostOrderBy
}

input PostLocalesByLocaleUniqueWhere {
  locale: Locale
}

type CategoryConnection {
  pageInfo: PageInfo!
  edges: [CategoryEdge!]!
}

type CategoryEdge {
  node: Category!
}

type PostLocaleConnection {
  pageInfo: PageInfo!
  edges: [PostLocaleEdge!]!
}

type PostLocaleEdge {
  node: PostLocale!
}

input AuthorPostsByLocalesUniqueWhere {
  locales: PostLocaleUniqueWhere
}

input PostLocaleUniqueWhere {
  id: UUID
  post: PostUniqueWhere
  locale: Locale
}

input PostUniqueWhere {
  id: UUID
  locales: PostLocaleUniqueWhere
}

input AuthorUniqueWhere {
  id: UUID
  posts: PostUniqueWhere
}

type AuthorConnection {
  pageInfo: PageInfo!
  edges: [AuthorEdge!]!
}

type AuthorEdge {
  node: Author!
}

type _ValidationResult {
  valid: Boolean!
  errors: [_ValidationError!]!
}

type _ValidationError {
  path: [_PathFragment!]!
  message: _ValidationMessage!
}

union _PathFragment = _FieldPathFragment | _IndexPathFragment

type _FieldPathFragment {
  field: String!
}

type _IndexPathFragment {
  index: Int!
  alias: String
}

type _ValidationMessage {
  text: String!
}

input AuthorCreateInput {
  name: String
  posts: [AuthorCreatePostsEntityRelationInput!]
  _dummy_field_: Boolean
}

input AuthorCreatePostsEntityRelationInput {
  connect: PostUniqueWhere
  create: PostWithoutAuthorCreateInput
  alias: String
}

input PostWithoutAuthorCreateInput {
  state: PostState
  publishedAt: DateTime
  categories: [PostCreateCategoriesEntityRelationInput!]
  locales: [PostCreateLocalesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostCreateCategoriesEntityRelationInput {
  connect: CategoryUniqueWhere
  create: CategoryWithoutPostsCreateInput
  alias: String
}

input CategoryUniqueWhere {
  id: UUID
  name: String
}

input CategoryWithoutPostsCreateInput {
  name: String
  _dummy_field_: Boolean
}

input PostCreateLocalesEntityRelationInput {
  connect: PostLocaleUniqueWhere
  create: PostLocaleWithoutPostCreateInput
  alias: String
}

input PostLocaleWithoutPostCreateInput {
  locale: Locale
  title: String
  _dummy_field_: Boolean
}

input AuthorUpdateInput {
  name: String
  posts: [AuthorUpdatePostsEntityRelationInput!]
  _dummy_field_: Boolean
}

input AuthorUpdatePostsEntityRelationInput {
  create: PostWithoutAuthorCreateInput
  update: AuthorUpdatePostsRelationInput
  upsert: AuthorUpsertPostsRelationInput
  connect: PostUniqueWhere
  disconnect: PostUniqueWhere
  delete: PostUniqueWhere
  alias: String
}

input AuthorUpdatePostsRelationInput {
  by: PostUniqueWhere
  data: PostWithoutAuthorUpdateInput
}

input PostWithoutAuthorUpdateInput {
  state: PostState
  publishedAt: DateTime
  categories: [PostUpdateCategoriesEntityRelationInput!]
  locales: [PostUpdateLocalesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostUpdateCategoriesEntityRelationInput {
  create: CategoryWithoutPostsCreateInput
  update: PostUpdateCategoriesRelationInput
  upsert: PostUpsertCategoriesRelationInput
  connect: CategoryUniqueWhere
  disconnect: CategoryUniqueWhere
  delete: CategoryUniqueWhere
  alias: String
}

input PostUpdateCategoriesRelationInput {
  by: CategoryUniqueWhere
  data: CategoryWithoutPostsUpdateInput
}

input CategoryWithoutPostsUpdateInput {
  name: String
  _dummy_field_: Boolean
}

input PostUpsertCategoriesRelationInput {
  by: CategoryUniqueWhere
  update: CategoryWithoutPostsUpdateInput
  create: CategoryWithoutPostsCreateInput
}

input PostUpdateLocalesEntityRelationInput {
  create: PostLocaleWithoutPostCreateInput
  update: PostUpdateLocalesRelationInput
  upsert: PostUpsertLocalesRelationInput
  connect: PostLocaleUniqueWhere
  disconnect: PostLocaleUniqueWhere
  delete: PostLocaleUniqueWhere
  alias: String
}

input PostUpdateLocalesRelationInput {
  by: PostLocaleUniqueWhere
  data: PostLocaleWithoutPostUpdateInput
}

input PostLocaleWithoutPostUpdateInput {
  locale: Locale
  title: String
  _dummy_field_: Boolean
}

input PostUpsertLocalesRelationInput {
  by: PostLocaleUniqueWhere
  update: PostLocaleWithoutPostUpdateInput
  create: PostLocaleWithoutPostCreateInput
}

input AuthorUpsertPostsRelationInput {
  by: PostUniqueWhere
  update: PostWithoutAuthorUpdateInput
  create: PostWithoutAuthorCreateInput
}

input PostCreateInput {
  state: PostState
  publishedAt: DateTime
  categories: [PostCreateCategoriesEntityRelationInput!]
  author: PostCreateAuthorEntityRelationInput
  locales: [PostCreateLocalesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostCreateAuthorEntityRelationInput {
  connect: AuthorUniqueWhere
  create: AuthorWithoutPostsCreateInput
}

input AuthorWithoutPostsCreateInput {
  name: String
  _dummy_field_: Boolean
}

input PostUpdateInput {
  state: PostState
  publishedAt: DateTime
  categories: [PostUpdateCategoriesEntityRelationInput!]
  author: PostUpdateAuthorEntityRelationInput
  locales: [PostUpdateLocalesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostUpdateAuthorEntityRelationInput {
  create: AuthorWithoutPostsCreateInput
  update: AuthorWithoutPostsUpdateInput
  upsert: PostUpsertAuthorRelationInput
  connect: AuthorUniqueWhere
  disconnect: Boolean
  delete: Boolean
}

input AuthorWithoutPostsUpdateInput {
  name: String
  _dummy_field_: Boolean
}

input PostUpsertAuthorRelationInput {
  update: AuthorWithoutPostsUpdateInput
  create: AuthorWithoutPostsCreateInput
}

input PostLocaleCreateInput {
  locale: Locale
  title: String
  post: PostLocaleCreatePostEntityRelationInput
  _dummy_field_: Boolean
}

input PostLocaleCreatePostEntityRelationInput {
  connect: PostUniqueWhere
  create: PostWithoutLocalesCreateInput
}

input PostWithoutLocalesCreateInput {
  state: PostState
  publishedAt: DateTime
  categories: [PostCreateCategoriesEntityRelationInput!]
  author: PostCreateAuthorEntityRelationInput
  _dummy_field_: Boolean
}

input PostLocaleUpdateInput {
  locale: Locale
  title: String
  post: PostLocaleUpdatePostEntityRelationInput
  _dummy_field_: Boolean
}

input PostLocaleUpdatePostEntityRelationInput {
  create: PostWithoutLocalesCreateInput
  update: PostWithoutLocalesUpdateInput
  upsert: PostLocaleUpsertPostRelationInput
  connect: PostUniqueWhere
  disconnect: Boolean
  delete: Boolean
}

input PostWithoutLocalesUpdateInput {
  state: PostState
  publishedAt: DateTime
  categories: [PostUpdateCategoriesEntityRelationInput!]
  author: PostUpdateAuthorEntityRelationInput
  _dummy_field_: Boolean
}

input PostLocaleUpsertPostRelationInput {
  update: PostWithoutLocalesUpdateInput
  create: PostWithoutLocalesCreateInput
}

input CategoryCreateInput {
  name: String
  posts: [CategoryCreatePostsEntityRelationInput!]
  _dummy_field_: Boolean
}

input CategoryCreatePostsEntityRelationInput {
  connect: PostUniqueWhere
  create: PostWithoutCategoriesCreateInput
  alias: String
}

input PostWithoutCategoriesCreateInput {
  state: PostState
  publishedAt: DateTime
  author: PostCreateAuthorEntityRelationInput
  locales: [PostCreateLocalesEntityRelationInput!]
  _dummy_field_: Boolean
}

input CategoryUpdateInput {
  name: String
  posts: [CategoryUpdatePostsEntityRelationInput!]
  _dummy_field_: Boolean
}

input CategoryUpdatePostsEntityRelationInput {
  create: PostWithoutCategoriesCreateInput
  update: CategoryUpdatePostsRelationInput
  upsert: CategoryUpsertPostsRelationInput
  connect: PostUniqueWhere
  disconnect: PostUniqueWhere
  delete: PostUniqueWhere
  alias: String
}

input CategoryUpdatePostsRelationInput {
  by: PostUniqueWhere
  data: PostWithoutCategoriesUpdateInput
}

input PostWithoutCategoriesUpdateInput {
  state: PostState
  publishedAt: DateTime
  author: PostUpdateAuthorEntityRelationInput
  locales: [PostUpdateLocalesEntityRelationInput!]
  _dummy_field_: Boolean
}

input CategoryUpsertPostsRelationInput {
  by: PostUniqueWhere
  update: PostWithoutCategoriesUpdateInput
  create: PostWithoutCategoriesCreateInput
}

type QueryTransaction {
  getAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere): Author
  listAuthor(filter: AuthorWhere, orderBy: [AuthorOrderBy!], offset: Int, limit: Int): [Author!]!
  paginateAuthor(filter: AuthorWhere, orderBy: [AuthorOrderBy!], skip: Int, first: Int): AuthorConnection!
  validateCreateAuthor(data: AuthorCreateInput!): _ValidationResult!
  validateUpdateAuthor(by: AuthorUniqueWhere!, data: AuthorUpdateInput!): _ValidationResult!
  getPost(by: PostUniqueWhere!, filter: PostWhere): Post
  listPost(filter: PostWhere, orderBy: [PostOrderBy!], offset: Int, limit: Int): [Post!]!
  paginatePost(filter: PostWhere, orderBy: [PostOrderBy!], skip: Int, first: Int): PostConnection!
  validateCreatePost(data: PostCreateInput!): _ValidationResult!
  validateUpdatePost(by: PostUniqueWhere!, data: PostUpdateInput!): _ValidationResult!
  getPostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere): PostLocale
  listPostLocale(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], offset: Int, limit: Int): [PostLocale!]!
  paginatePostLocale(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], skip: Int, first: Int): PostLocaleConnection!
  validateCreatePostLocale(data: PostLocaleCreateInput!): _ValidationResult!
  validateUpdatePostLocale(by: PostLocaleUniqueWhere!, data: PostLocaleUpdateInput!): _ValidationResult!
  getCategory(by: CategoryUniqueWhere!, filter: CategoryWhere): Category
  listCategory(filter: CategoryWhere, orderBy: [CategoryOrderBy!], offset: Int, limit: Int): [Category!]!
  paginateCategory(filter: CategoryWhere, orderBy: [CategoryOrderBy!], skip: Int, first: Int): CategoryConnection!
  validateCreateCategory(data: CategoryCreateInput!): _ValidationResult!
  validateUpdateCategory(by: CategoryUniqueWhere!, data: CategoryUpdateInput!): _ValidationResult!
}

type Info {
  description: String
}

type Mutation {
  createAuthor(data: AuthorCreateInput!): AuthorCreateResult!
  deleteAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere): AuthorDeleteResult!
  updateAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere, data: AuthorUpdateInput!): AuthorUpdateResult!
  upsertAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere, update: AuthorUpdateInput!, create: AuthorCreateInput!): AuthorUpsertResult!
  createPost(data: PostCreateInput!): PostCreateResult!
  deletePost(by: PostUniqueWhere!, filter: PostWhere): PostDeleteResult!
  updatePost(by: PostUniqueWhere!, filter: PostWhere, data: PostUpdateInput!): PostUpdateResult!
  upsertPost(by: PostUniqueWhere!, filter: PostWhere, update: PostUpdateInput!, create: PostCreateInput!): PostUpsertResult!
  createPostLocale(data: PostLocaleCreateInput!): PostLocaleCreateResult!
  deletePostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere): PostLocaleDeleteResult!
  updatePostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere, data: PostLocaleUpdateInput!): PostLocaleUpdateResult!
  upsertPostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere, update: PostLocaleUpdateInput!, create: PostLocaleCreateInput!): PostLocaleUpsertResult!
  createCategory(data: CategoryCreateInput!): CategoryCreateResult!
  deleteCategory(by: CategoryUniqueWhere!, filter: CategoryWhere): CategoryDeleteResult!
  updateCategory(by: CategoryUniqueWhere!, filter: CategoryWhere, data: CategoryUpdateInput!): CategoryUpdateResult!
  upsertCategory(by: CategoryUniqueWhere!, filter: CategoryWhere, update: CategoryUpdateInput!, create: CategoryCreateInput!): CategoryUpsertResult!
  transaction(options: MutationTransactionOptions): MutationTransaction!
  query: Query!
}

type AuthorCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Author
  validation: _ValidationResult!
}

interface MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
}

type _MutationError {
  path: [_PathFragment!]! @deprecated(reason: \\"Use \`paths\`.\\")
  paths: [[_PathFragment!]!]!
  type: _MutationErrorType!
  message: String
}

enum _MutationErrorType {
  NotNullConstraintViolation
  UniqueConstraintViolation
  ForeignKeyConstraintViolation
  NotFoundOrDenied
  NonUniqueWhereInput
  InvalidDataInput
  SqlError
}

type AuthorDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Author
}

type AuthorUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Author
  validation: _ValidationResult!
}

type AuthorUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Author
  validation: _ValidationResult!
}

type PostCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Post
  validation: _ValidationResult!
}

type PostDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Post
}

type PostUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Post
  validation: _ValidationResult!
}

type PostUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Post
  validation: _ValidationResult!
}

type PostLocaleCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: PostLocale
  validation: _ValidationResult!
}

type PostLocaleDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: PostLocale
}

type PostLocaleUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: PostLocale
  validation: _ValidationResult!
}

type PostLocaleUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: PostLocale
  validation: _ValidationResult!
}

type CategoryCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Category
  validation: _ValidationResult!
}

type CategoryDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Category
}

type CategoryUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Category
  validation: _ValidationResult!
}

type CategoryUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Category
  validation: _ValidationResult!
}

type MutationTransaction {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  validation: _ValidationResult!
  createAuthor(data: AuthorCreateInput!): AuthorCreateResult!
  deleteAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere): AuthorDeleteResult!
  updateAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere, data: AuthorUpdateInput!): AuthorUpdateResult!
  upsertAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere, update: AuthorUpdateInput!, create: AuthorCreateInput!): AuthorUpsertResult!
  createPost(data: PostCreateInput!): PostCreateResult!
  deletePost(by: PostUniqueWhere!, filter: PostWhere): PostDeleteResult!
  updatePost(by: PostUniqueWhere!, filter: PostWhere, data: PostUpdateInput!): PostUpdateResult!
  upsertPost(by: PostUniqueWhere!, filter: PostWhere, update: PostUpdateInput!, create: PostCreateInput!): PostUpsertResult!
  createPostLocale(data: PostLocaleCreateInput!): PostLocaleCreateResult!
  deletePostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere): PostLocaleDeleteResult!
  updatePostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere, data: PostLocaleUpdateInput!): PostLocaleUpdateResult!
  upsertPostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere, update: PostLocaleUpdateInput!, create: PostLocaleCreateInput!): PostLocaleUpsertResult!
  createCategory(data: CategoryCreateInput!): CategoryCreateResult!
  deleteCategory(by: CategoryUniqueWhere!, filter: CategoryWhere): CategoryDeleteResult!
  updateCategory(by: CategoryUniqueWhere!, filter: CategoryWhere, data: CategoryUpdateInput!): CategoryUpdateResult!
  upsertCategory(by: CategoryUniqueWhere!, filter: CategoryWhere, update: CategoryUpdateInput!, create: CategoryCreateInput!): CategoryUpsertResult!
  query: Query
}

input MutationTransactionOptions {
  deferForeignKeyConstraints: Boolean
}
"
`;

exports[`GraphQL schema builder > bug with multiple relations 66 1`] = `
"type Query {
  getVideo(by: VideoUniqueWhere!, filter: VideoWhere): Video
  listVideo(filter: VideoWhere, orderBy: [VideoOrderBy!], offset: Int, limit: Int): [Video!]!
  paginateVideo(filter: VideoWhere, orderBy: [VideoOrderBy!], skip: Int, first: Int): VideoConnection!
  validateCreateVideo(data: VideoCreateInput!): _ValidationResult!
  validateUpdateVideo(by: VideoUniqueWhere!, data: VideoUpdateInput!): _ValidationResult!
  getFrontPage(by: FrontPageUniqueWhere!, filter: FrontPageWhere): FrontPage
  listFrontPage(filter: FrontPageWhere, orderBy: [FrontPageOrderBy!], offset: Int, limit: Int): [FrontPage!]!
  paginateFrontPage(filter: FrontPageWhere, orderBy: [FrontPageOrderBy!], skip: Int, first: Int): FrontPageConnection!
  validateCreateFrontPage(data: FrontPageCreateInput!): _ValidationResult!
  validateUpdateFrontPage(by: FrontPageUniqueWhere!, data: FrontPageUpdateInput!): _ValidationResult!
  transaction: QueryTransaction
  _info: Info
}

type Video {
  _meta: VideoMeta
  id: UUID!
  vimeoId: String
  frontPageForIntro(filter: FrontPageWhere): FrontPage
  frontPage(filter: FrontPageWhere): FrontPage
}

type VideoMeta {
  id: FieldMeta
  vimeoId: FieldMeta
  frontPageForIntro: FieldMeta
  frontPage: FieldMeta
}

type FieldMeta {
  readable: Boolean
  updatable: Boolean
}

scalar UUID

type FrontPage {
  _meta: FrontPageMeta
  id: UUID!
  unique: One!
  introVideo(filter: VideoWhere): Video
  inHouseVideos(filter: VideoWhere, orderBy: [VideoOrderBy!], offset: Int, limit: Int): [Video!]!
  inHouseVideosByFrontPageForIntro(by: FrontPageInHouseVideosByFrontPageForIntroUniqueWhere!, filter: VideoWhere): Video
  paginateInHouseVideos(filter: VideoWhere, orderBy: [VideoOrderBy!], skip: Int, first: Int): VideoConnection!
}

type FrontPageMeta {
  id: FieldMeta
  unique: FieldMeta
  introVideo: FieldMeta
  inHouseVideos: FieldMeta
}

enum One {
  one
}

input VideoWhere {
  id: UUIDCondition
  vimeoId: StringCondition
  frontPageForIntro: FrontPageWhere
  frontPage: FrontPageWhere
  and: [VideoWhere]
  or: [VideoWhere]
  not: VideoWhere
}

input UUIDCondition {
  and: [UUIDCondition!]
  or: [UUIDCondition!]
  not: UUIDCondition
  null: Boolean
  isNull: Boolean
  eq: UUID
  notEq: UUID
  in: [UUID!]
  notIn: [UUID!]
  lt: UUID
  lte: UUID
  gt: UUID
  gte: UUID
}

input StringCondition {
  and: [StringCondition!]
  or: [StringCondition!]
  not: StringCondition
  null: Boolean
  isNull: Boolean
  eq: String
  notEq: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  containsCI: String
  startsWithCI: String
  endsWithCI: String
}

input FrontPageWhere {
  id: UUIDCondition
  unique: OneEnumCondition
  introVideo: VideoWhere
  inHouseVideos: VideoWhere
  and: [FrontPageWhere]
  or: [FrontPageWhere]
  not: FrontPageWhere
}

input OneEnumCondition {
  and: [OneEnumCondition!]
  or: [OneEnumCondition!]
  not: OneEnumCondition
  null: Boolean
  isNull: Boolean
  eq: One
  notEq: One
  in: [One!]
  notIn: [One!]
  lt: One
  lte: One
  gt: One
  gte: One
}

input VideoOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  vimeoId: OrderDirection
  frontPageForIntro: FrontPageOrderBy
  frontPage: FrontPageOrderBy
}

enum OrderDirection {
  asc
  desc
  ascNullsFirst
  descNullsLast
}

input FrontPageOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  unique: OrderDirection
  introVideo: VideoOrderBy
}

input FrontPageInHouseVideosByFrontPageForIntroUniqueWhere {
  frontPageForIntro: FrontPageUniqueWhere
}

input FrontPageUniqueWhere {
  id: UUID
  unique: One
  introVideo: VideoUniqueWhere
  inHouseVideos: VideoUniqueWhere
}

input VideoUniqueWhere {
  id: UUID
  frontPageForIntro: FrontPageUniqueWhere
}

type VideoConnection {
  pageInfo: PageInfo!
  edges: [VideoEdge!]!
}

type PageInfo {
  totalCount: Int!
}

type VideoEdge {
  node: Video!
}

type _ValidationResult {
  valid: Boolean!
  errors: [_ValidationError!]!
}

type _ValidationError {
  path: [_PathFragment!]!
  message: _ValidationMessage!
}

union _PathFragment = _FieldPathFragment | _IndexPathFragment

type _FieldPathFragment {
  field: String!
}

type _IndexPathFragment {
  index: Int!
  alias: String
}

type _ValidationMessage {
  text: String!
}

input VideoCreateInput {
  vimeoId: String
  frontPageForIntro: VideoCreateFrontPageForIntroEntityRelationInput
  frontPage: VideoCreateFrontPageEntityRelationInput
  _dummy_field_: Boolean
}

input VideoCreateFrontPageForIntroEntityRelationInput {
  connect: FrontPageUniqueWhere
  create: FrontPageWithoutIntroVideoCreateInput
}

input FrontPageWithoutIntroVideoCreateInput {
  unique: One
  inHouseVideos: [FrontPageCreateInHouseVideosEntityRelationInput!]
  _dummy_field_: Boolean
}

input FrontPageCreateInHouseVideosEntityRelationInput {
  connect: VideoUniqueWhere
  create: VideoWithoutFrontPageCreateInput
  alias: String
}

input VideoWithoutFrontPageCreateInput {
  vimeoId: String
  frontPageForIntro: VideoCreateFrontPageForIntroEntityRelationInput
  _dummy_field_: Boolean
}

input VideoCreateFrontPageEntityRelationInput {
  connect: FrontPageUniqueWhere
  create: FrontPageWithoutInHouseVideosCreateInput
}

input FrontPageWithoutInHouseVideosCreateInput {
  unique: One
  introVideo: FrontPageCreateIntroVideoEntityRelationInput
  _dummy_field_: Boolean
}

input FrontPageCreateIntroVideoEntityRelationInput {
  connect: VideoUniqueWhere
  create: VideoWithoutFrontPageForIntroCreateInput
}

input VideoWithoutFrontPageForIntroCreateInput {
  vimeoId: String
  frontPage: VideoCreateFrontPageEntityRelationInput
  _dummy_field_: Boolean
}

input VideoUpdateInput {
  vimeoId: String
  frontPageForIntro: VideoUpdateFrontPageForIntroEntityRelationInput
  frontPage: VideoUpdateFrontPageEntityRelationInput
  _dummy_field_: Boolean
}

input VideoUpdateFrontPageForIntroEntityRelationInput {
  create: FrontPageWithoutIntroVideoCreateInput
  update: FrontPageWithoutIntroVideoUpdateInput
  upsert: VideoUpsertFrontPageForIntroRelationInput
  connect: FrontPageUniqueWhere
  disconnect: Boolean
  delete: Boolean
}

input FrontPageWithoutIntroVideoUpdateInput {
  unique: One
  inHouseVideos: [FrontPageUpdateInHouseVideosEntityRelationInput!]
  _dummy_field_: Boolean
}

input FrontPageUpdateInHouseVideosEntityRelationInput {
  create: VideoWithoutFrontPageCreateInput
  update: FrontPageUpdateInHouseVideosRelationInput
  upsert: FrontPageUpsertInHouseVideosRelationInput
  connect: VideoUniqueWhere
  disconnect: VideoUniqueWhere
  delete: VideoUniqueWhere
  alias: String
}

input FrontPageUpdateInHouseVideosRelationInput {
  by: VideoUniqueWhere
  data: VideoWithoutFrontPageUpdateInput
}

input VideoWithoutFrontPageUpdateInput {
  vimeoId: String
  frontPageForIntro: VideoUpdateFrontPageForIntroEntityRelationInput
  _dummy_field_: Boolean
}

input FrontPageUpsertInHouseVideosRelationInput {
  by: VideoUniqueWhere
  update: VideoWithoutFrontPageUpdateInput
  create: VideoWithoutFrontPageCreateInput
}

input VideoUpsertFrontPageForIntroRelationInput {
  update: FrontPageWithoutIntroVideoUpdateInput
  create: FrontPageWithoutIntroVideoCreateInput
}

input VideoUpdateFrontPageEntityRelationInput {
  create: FrontPageWithoutInHouseVideosCreateInput
  update: FrontPageWithoutInHouseVideosUpdateInput
  upsert: VideoUpsertFrontPageRelationInput
  connect: FrontPageUniqueWhere
  disconnect: Boolean
  delete: Boolean
}

input FrontPageWithoutInHouseVideosUpdateInput {
  unique: One
  introVideo: FrontPageUpdateIntroVideoEntityRelationInput
  _dummy_field_: Boolean
}

input FrontPageUpdateIntroVideoEntityRelationInput {
  create: VideoWithoutFrontPageForIntroCreateInput
  update: VideoWithoutFrontPageForIntroUpdateInput
  upsert: FrontPageUpsertIntroVideoRelationInput
  connect: VideoUniqueWhere
  disconnect: Boolean
  delete: Boolean
}

input VideoWithoutFrontPageForIntroUpdateInput {
  vimeoId: String
  frontPage: VideoUpdateFrontPageEntityRelationInput
  _dummy_field_: Boolean
}

input FrontPageUpsertIntroVideoRelationInput {
  update: VideoWithoutFrontPageForIntroUpdateInput
  create: VideoWithoutFrontPageForIntroCreateInput
}

input VideoUpsertFrontPageRelationInput {
  update: FrontPageWithoutInHouseVideosUpdateInput
  create: FrontPageWithoutInHouseVideosCreateInput
}

type FrontPageConnection {
  pageInfo: PageInfo!
  edges: [FrontPageEdge!]!
}

type FrontPageEdge {
  node: FrontPage!
}

input FrontPageCreateInput {
  unique: One
  introVideo: FrontPageCreateIntroVideoEntityRelationInput
  inHouseVideos: [FrontPageCreateInHouseVideosEntityRelationInput!]
  _dummy_field_: Boolean
}

input FrontPageUpdateInput {
  unique: One
  introVideo: FrontPageUpdateIntroVideoEntityRelationInput
  inHouseVideos: [FrontPageUpdateInHouseVideosEntityRelationInput!]
  _dummy_field_: Boolean
}

type QueryTransaction {
  getVideo(by: VideoUniqueWhere!, filter: VideoWhere): Video
  listVideo(filter: VideoWhere, orderBy: [VideoOrderBy!], offset: Int, limit: Int): [Video!]!
  paginateVideo(filter: VideoWhere, orderBy: [VideoOrderBy!], skip: Int, first: Int): VideoConnection!
  validateCreateVideo(data: VideoCreateInput!): _ValidationResult!
  validateUpdateVideo(by: VideoUniqueWhere!, data: VideoUpdateInput!): _ValidationResult!
  getFrontPage(by: FrontPageUniqueWhere!, filter: FrontPageWhere): FrontPage
  listFrontPage(filter: FrontPageWhere, orderBy: [FrontPageOrderBy!], offset: Int, limit: Int): [FrontPage!]!
  paginateFrontPage(filter: FrontPageWhere, orderBy: [FrontPageOrderBy!], skip: Int, first: Int): FrontPageConnection!
  validateCreateFrontPage(data: FrontPageCreateInput!): _ValidationResult!
  validateUpdateFrontPage(by: FrontPageUniqueWhere!, data: FrontPageUpdateInput!): _ValidationResult!
}

type Info {
  description: String
}

type Mutation {
  createVideo(data: VideoCreateInput!): VideoCreateResult!
  deleteVideo(by: VideoUniqueWhere!, filter: VideoWhere): VideoDeleteResult!
  updateVideo(by: VideoUniqueWhere!, filter: VideoWhere, data: VideoUpdateInput!): VideoUpdateResult!
  upsertVideo(by: VideoUniqueWhere!, filter: VideoWhere, update: VideoUpdateInput!, create: VideoCreateInput!): VideoUpsertResult!
  createFrontPage(data: FrontPageCreateInput!): FrontPageCreateResult!
  deleteFrontPage(by: FrontPageUniqueWhere!, filter: FrontPageWhere): FrontPageDeleteResult!
  updateFrontPage(by: FrontPageUniqueWhere!, filter: FrontPageWhere, data: FrontPageUpdateInput!): FrontPageUpdateResult!
  upsertFrontPage(by: FrontPageUniqueWhere!, filter: FrontPageWhere, update: FrontPageUpdateInput!, create: FrontPageCreateInput!): FrontPageUpsertResult!
  transaction(options: MutationTransactionOptions): MutationTransaction!
  query: Query!
}

type VideoCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Video
  validation: _ValidationResult!
}

interface MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
}

type _MutationError {
  path: [_PathFragment!]! @deprecated(reason: \\"Use \`paths\`.\\")
  paths: [[_PathFragment!]!]!
  type: _MutationErrorType!
  message: String
}

enum _MutationErrorType {
  NotNullConstraintViolation
  UniqueConstraintViolation
  ForeignKeyConstraintViolation
  NotFoundOrDenied
  NonUniqueWhereInput
  InvalidDataInput
  SqlError
}

type VideoDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Video
}

type VideoUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Video
  validation: _ValidationResult!
}

type VideoUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Video
  validation: _ValidationResult!
}

type FrontPageCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: FrontPage
  validation: _ValidationResult!
}

type FrontPageDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: FrontPage
}

type FrontPageUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: FrontPage
  validation: _ValidationResult!
}

type FrontPageUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: FrontPage
  validation: _ValidationResult!
}

type MutationTransaction {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  validation: _ValidationResult!
  createVideo(data: VideoCreateInput!): VideoCreateResult!
  deleteVideo(by: VideoUniqueWhere!, filter: VideoWhere): VideoDeleteResult!
  updateVideo(by: VideoUniqueWhere!, filter: VideoWhere, data: VideoUpdateInput!): VideoUpdateResult!
  upsertVideo(by: VideoUniqueWhere!, filter: VideoWhere, update: VideoUpdateInput!, create: VideoCreateInput!): VideoUpsertResult!
  createFrontPage(data: FrontPageCreateInput!): FrontPageCreateResult!
  deleteFrontPage(by: FrontPageUniqueWhere!, filter: FrontPageWhere): FrontPageDeleteResult!
  updateFrontPage(by: FrontPageUniqueWhere!, filter: FrontPageWhere, data: FrontPageUpdateInput!): FrontPageUpdateResult!
  upsertFrontPage(by: FrontPageUniqueWhere!, filter: FrontPageWhere, update: FrontPageUpdateInput!, create: FrontPageCreateInput!): FrontPageUpsertResult!
  query: Query
}

input MutationTransactionOptions {
  deferForeignKeyConstraints: Boolean
}
"
`;

exports[`GraphQL schema builder > conditionally restricted read of some fields 1`] = `
"type Query {
  getTest(by: TestUniqueWhere!, filter: TestWhere): Test
  listTest(filter: TestWhere, orderBy: [TestOrderBy!], offset: Int, limit: Int): [Test!]!
  paginateTest(filter: TestWhere, orderBy: [TestOrderBy!], skip: Int, first: Int): TestConnection!
  transaction: QueryTransaction
  _info: Info
}

type Test {
  _meta: TestMeta
  id: UUID!
  a: String
}

type TestMeta {
  id: FieldMeta
  a: FieldMeta
}

type FieldMeta {
  readable: Boolean
  updatable: Boolean
}

scalar UUID

input TestUniqueWhere {
  id: UUID
}

input TestWhere {
  id: UUIDCondition
  a: StringCondition
  and: [TestWhere]
  or: [TestWhere]
  not: TestWhere
}

input UUIDCondition {
  and: [UUIDCondition!]
  or: [UUIDCondition!]
  not: UUIDCondition
  null: Boolean
  isNull: Boolean
  eq: UUID
  notEq: UUID
  in: [UUID!]
  notIn: [UUID!]
  lt: UUID
  lte: UUID
  gt: UUID
  gte: UUID
}

input StringCondition {
  and: [StringCondition!]
  or: [StringCondition!]
  not: StringCondition
  null: Boolean
  isNull: Boolean
  eq: String
  notEq: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  containsCI: String
  startsWithCI: String
  endsWithCI: String
}

input TestOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  a: OrderDirection
}

enum OrderDirection {
  asc
  desc
  ascNullsFirst
  descNullsLast
}

type TestConnection {
  pageInfo: PageInfo!
  edges: [TestEdge!]!
}

type PageInfo {
  totalCount: Int!
}

type TestEdge {
  node: Test!
}

type QueryTransaction {
  getTest(by: TestUniqueWhere!, filter: TestWhere): Test
  listTest(filter: TestWhere, orderBy: [TestOrderBy!], offset: Int, limit: Int): [Test!]!
  paginateTest(filter: TestWhere, orderBy: [TestOrderBy!], skip: Int, first: Int): TestConnection!
}

type Info {
  description: String
}
"
`;

exports[`GraphQL schema builder > conditionally restricted read of whole row 1`] = `
"type Query {
  getTest(by: TestUniqueWhere!, filter: TestWhere): Test
  listTest(filter: TestWhere, orderBy: [TestOrderBy!], offset: Int, limit: Int): [Test!]!
  paginateTest(filter: TestWhere, orderBy: [TestOrderBy!], skip: Int, first: Int): TestConnection!
  transaction: QueryTransaction
  _info: Info
}

type Test {
  _meta: TestMeta
  id: UUID!
  a: String!
}

type TestMeta {
  id: FieldMeta
  a: FieldMeta
}

type FieldMeta {
  readable: Boolean
  updatable: Boolean
}

scalar UUID

input TestUniqueWhere {
  id: UUID
}

input TestWhere {
  id: UUIDCondition
  a: StringCondition
  and: [TestWhere]
  or: [TestWhere]
  not: TestWhere
}

input UUIDCondition {
  and: [UUIDCondition!]
  or: [UUIDCondition!]
  not: UUIDCondition
  null: Boolean
  isNull: Boolean
  eq: UUID
  notEq: UUID
  in: [UUID!]
  notIn: [UUID!]
  lt: UUID
  lte: UUID
  gt: UUID
  gte: UUID
}

input StringCondition {
  and: [StringCondition!]
  or: [StringCondition!]
  not: StringCondition
  null: Boolean
  isNull: Boolean
  eq: String
  notEq: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  containsCI: String
  startsWithCI: String
  endsWithCI: String
}

input TestOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  a: OrderDirection
}

enum OrderDirection {
  asc
  desc
  ascNullsFirst
  descNullsLast
}

type TestConnection {
  pageInfo: PageInfo!
  edges: [TestEdge!]!
}

type PageInfo {
  totalCount: Int!
}

type TestEdge {
  node: Test!
}

type QueryTransaction {
  getTest(by: TestUniqueWhere!, filter: TestWhere): Test
  listTest(filter: TestWhere, orderBy: [TestOrderBy!], offset: Int, limit: Int): [Test!]!
  paginateTest(filter: TestWhere, orderBy: [TestOrderBy!], skip: Int, first: Int): TestConnection!
}

type Info {
  description: String
}
"
`;

exports[`GraphQL schema builder > custom primary allowed 1`] = `
"type Query {
  getAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere): Author
  listAuthor(filter: AuthorWhere, orderBy: [AuthorOrderBy!], offset: Int, limit: Int): [Author!]!
  paginateAuthor(filter: AuthorWhere, orderBy: [AuthorOrderBy!], skip: Int, first: Int): AuthorConnection!
  validateCreateAuthor(data: AuthorCreateInput!): _ValidationResult!
  validateUpdateAuthor(by: AuthorUniqueWhere!, data: AuthorUpdateInput!): _ValidationResult!
  getCategory(by: CategoryUniqueWhere!, filter: CategoryWhere): Category
  listCategory(filter: CategoryWhere, orderBy: [CategoryOrderBy!], offset: Int, limit: Int): [Category!]!
  paginateCategory(filter: CategoryWhere, orderBy: [CategoryOrderBy!], skip: Int, first: Int): CategoryConnection!
  validateCreateCategory(data: CategoryCreateInput!): _ValidationResult!
  validateUpdateCategory(by: CategoryUniqueWhere!, data: CategoryUpdateInput!): _ValidationResult!
  getPostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere): PostLocale
  listPostLocale(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], offset: Int, limit: Int): [PostLocale!]!
  paginatePostLocale(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], skip: Int, first: Int): PostLocaleConnection!
  validateCreatePostLocale(data: PostLocaleCreateInput!): _ValidationResult!
  validateUpdatePostLocale(by: PostLocaleUniqueWhere!, data: PostLocaleUpdateInput!): _ValidationResult!
  getPost(by: PostUniqueWhere!, filter: PostWhere): Post
  listPost(filter: PostWhere, orderBy: [PostOrderBy!], offset: Int, limit: Int): [Post!]!
  paginatePost(filter: PostWhere, orderBy: [PostOrderBy!], skip: Int, first: Int): PostConnection!
  validateCreatePost(data: PostCreateInput!): _ValidationResult!
  validateUpdatePost(by: PostUniqueWhere!, data: PostUpdateInput!): _ValidationResult!
  transaction: QueryTransaction
  _info: Info
}

type Author {
  _meta: AuthorMeta
  id: UUID!
  name: String
  posts(filter: PostWhere, orderBy: [PostOrderBy!], offset: Int, limit: Int): [Post!]!
  postsByLocales(by: AuthorPostsByLocalesUniqueWhere!, filter: PostWhere): Post
  paginatePosts(filter: PostWhere, orderBy: [PostOrderBy!], skip: Int, first: Int): PostConnection!
}

type AuthorMeta {
  id: FieldMeta
  name: FieldMeta
  posts: FieldMeta
}

type FieldMeta {
  readable: Boolean
  updatable: Boolean
}

scalar UUID

type Post {
  _meta: PostMeta
  author(filter: AuthorWhere): Author
  id: UUID!
  publishedAt: DateTime
  locales(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], offset: Int, limit: Int): [PostLocale!]!
  categories(filter: CategoryWhere, orderBy: [CategoryOrderBy!], offset: Int, limit: Int): [Category!]!
  paginateLocales(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], skip: Int, first: Int): PostLocaleConnection!
  paginateCategories(filter: CategoryWhere, orderBy: [CategoryOrderBy!], skip: Int, first: Int): CategoryConnection!
}

type PostMeta {
  author: FieldMeta
  id: FieldMeta
  publishedAt: FieldMeta
  locales: FieldMeta
  categories: FieldMeta
}

input AuthorWhere {
  id: UUIDCondition
  name: StringCondition
  posts: PostWhere
  and: [AuthorWhere]
  or: [AuthorWhere]
  not: AuthorWhere
}

input UUIDCondition {
  and: [UUIDCondition!]
  or: [UUIDCondition!]
  not: UUIDCondition
  null: Boolean
  isNull: Boolean
  eq: UUID
  notEq: UUID
  in: [UUID!]
  notIn: [UUID!]
  lt: UUID
  lte: UUID
  gt: UUID
  gte: UUID
}

input StringCondition {
  and: [StringCondition!]
  or: [StringCondition!]
  not: StringCondition
  null: Boolean
  isNull: Boolean
  eq: String
  notEq: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  containsCI: String
  startsWithCI: String
  endsWithCI: String
}

input PostWhere {
  author: AuthorWhere
  id: UUIDCondition
  publishedAt: DateTimeCondition
  locales: PostLocaleWhere
  categories: CategoryWhere
  and: [PostWhere]
  or: [PostWhere]
  not: PostWhere
}

input DateTimeCondition {
  and: [DateTimeCondition!]
  or: [DateTimeCondition!]
  not: DateTimeCondition
  null: Boolean
  isNull: Boolean
  eq: DateTime
  notEq: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
}

scalar DateTime

input PostLocaleWhere {
  id: UUIDCondition
  title: StringCondition
  Post: PostWhere
  and: [PostLocaleWhere]
  or: [PostLocaleWhere]
  not: PostLocaleWhere
}

input CategoryWhere {
  id: UUIDCondition
  name: StringCondition
  posts: PostWhere
  and: [CategoryWhere]
  or: [CategoryWhere]
  not: CategoryWhere
}

type PostLocale {
  _meta: PostLocaleMeta
  id: UUID!
  title: String
  Post(filter: PostWhere): Post
}

type PostLocaleMeta {
  id: FieldMeta
  title: FieldMeta
  Post: FieldMeta
}

input PostLocaleOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  title: OrderDirection
  Post: PostOrderBy
}

enum OrderDirection {
  asc
  desc
  ascNullsFirst
  descNullsLast
}

input PostOrderBy {
  _random: Boolean
  _randomSeeded: Int
  author: AuthorOrderBy
  id: OrderDirection
  publishedAt: OrderDirection
}

input AuthorOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  name: OrderDirection
}

type Category {
  _meta: CategoryMeta
  id: UUID!
  name: String
  posts(filter: PostWhere, orderBy: [PostOrderBy!], offset: Int, limit: Int): [Post!]!
  paginatePosts(filter: PostWhere, orderBy: [PostOrderBy!], skip: Int, first: Int): PostConnection!
}

type CategoryMeta {
  id: FieldMeta
  name: FieldMeta
  posts: FieldMeta
}

type PostConnection {
  pageInfo: PageInfo!
  edges: [PostEdge!]!
}

type PageInfo {
  totalCount: Int!
}

type PostEdge {
  node: Post!
}

input CategoryOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  name: OrderDirection
}

type PostLocaleConnection {
  pageInfo: PageInfo!
  edges: [PostLocaleEdge!]!
}

type PostLocaleEdge {
  node: PostLocale!
}

type CategoryConnection {
  pageInfo: PageInfo!
  edges: [CategoryEdge!]!
}

type CategoryEdge {
  node: Category!
}

input AuthorPostsByLocalesUniqueWhere {
  locales: PostLocaleUniqueWhere
}

input PostLocaleUniqueWhere {
  id: UUID
}

input AuthorUniqueWhere {
  id: UUID
  posts: PostUniqueWhere
}

input PostUniqueWhere {
  id: UUID
  locales: PostLocaleUniqueWhere
}

type AuthorConnection {
  pageInfo: PageInfo!
  edges: [AuthorEdge!]!
}

type AuthorEdge {
  node: Author!
}

type _ValidationResult {
  valid: Boolean!
  errors: [_ValidationError!]!
}

type _ValidationError {
  path: [_PathFragment!]!
  message: _ValidationMessage!
}

union _PathFragment = _FieldPathFragment | _IndexPathFragment

type _FieldPathFragment {
  field: String!
}

type _IndexPathFragment {
  index: Int!
  alias: String
}

type _ValidationMessage {
  text: String!
}

input AuthorCreateInput {
  id: UUID
  name: String
  posts: [AuthorCreatePostsEntityRelationInput!]
  _dummy_field_: Boolean
}

input AuthorCreatePostsEntityRelationInput {
  connect: PostUniqueWhere
  create: PostWithoutAuthorCreateInput
  alias: String
}

input PostWithoutAuthorCreateInput {
  id: UUID
  publishedAt: DateTime
  locales: [PostCreateLocalesEntityRelationInput!]
  categories: [PostCreateCategoriesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostCreateLocalesEntityRelationInput {
  connect: PostLocaleUniqueWhere
  create: PostLocaleWithoutPostCreateInput
  alias: String
}

input PostLocaleWithoutPostCreateInput {
  id: UUID
  title: String
  _dummy_field_: Boolean
}

input PostCreateCategoriesEntityRelationInput {
  connect: CategoryUniqueWhere
  create: CategoryWithoutPostsCreateInput
  alias: String
}

input CategoryUniqueWhere {
  id: UUID
}

input CategoryWithoutPostsCreateInput {
  id: UUID
  name: String
  _dummy_field_: Boolean
}

input AuthorUpdateInput {
  name: String
  posts: [AuthorUpdatePostsEntityRelationInput!]
  _dummy_field_: Boolean
}

input AuthorUpdatePostsEntityRelationInput {
  create: PostWithoutAuthorCreateInput
  update: AuthorUpdatePostsRelationInput
  upsert: AuthorUpsertPostsRelationInput
  connect: PostUniqueWhere
  disconnect: PostUniqueWhere
  delete: PostUniqueWhere
  alias: String
}

input AuthorUpdatePostsRelationInput {
  by: PostUniqueWhere
  data: PostWithoutAuthorUpdateInput
}

input PostWithoutAuthorUpdateInput {
  publishedAt: DateTime
  locales: [PostUpdateLocalesEntityRelationInput!]
  categories: [PostUpdateCategoriesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostUpdateLocalesEntityRelationInput {
  create: PostLocaleWithoutPostCreateInput
  update: PostUpdateLocalesRelationInput
  upsert: PostUpsertLocalesRelationInput
  connect: PostLocaleUniqueWhere
  disconnect: PostLocaleUniqueWhere
  delete: PostLocaleUniqueWhere
  alias: String
}

input PostUpdateLocalesRelationInput {
  by: PostLocaleUniqueWhere
  data: PostLocaleWithoutPostUpdateInput
}

input PostLocaleWithoutPostUpdateInput {
  title: String
  _dummy_field_: Boolean
}

input PostUpsertLocalesRelationInput {
  by: PostLocaleUniqueWhere
  update: PostLocaleWithoutPostUpdateInput
  create: PostLocaleWithoutPostCreateInput
}

input PostUpdateCategoriesEntityRelationInput {
  create: CategoryWithoutPostsCreateInput
  update: PostUpdateCategoriesRelationInput
  upsert: PostUpsertCategoriesRelationInput
  connect: CategoryUniqueWhere
  disconnect: CategoryUniqueWhere
  delete: CategoryUniqueWhere
  alias: String
}

input PostUpdateCategoriesRelationInput {
  by: CategoryUniqueWhere
  data: CategoryWithoutPostsUpdateInput
}

input CategoryWithoutPostsUpdateInput {
  name: String
  _dummy_field_: Boolean
}

input PostUpsertCategoriesRelationInput {
  by: CategoryUniqueWhere
  update: CategoryWithoutPostsUpdateInput
  create: CategoryWithoutPostsCreateInput
}

input AuthorUpsertPostsRelationInput {
  by: PostUniqueWhere
  update: PostWithoutAuthorUpdateInput
  create: PostWithoutAuthorCreateInput
}

input CategoryCreateInput {
  id: UUID
  name: String
  posts: [CategoryCreatePostsEntityRelationInput!]
  _dummy_field_: Boolean
}

input CategoryCreatePostsEntityRelationInput {
  connect: PostUniqueWhere
  create: PostWithoutCategoriesCreateInput
  alias: String
}

input PostWithoutCategoriesCreateInput {
  author: PostCreateAuthorEntityRelationInput
  id: UUID
  publishedAt: DateTime
  locales: [PostCreateLocalesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostCreateAuthorEntityRelationInput {
  connect: AuthorUniqueWhere
  create: AuthorWithoutPostsCreateInput
}

input AuthorWithoutPostsCreateInput {
  id: UUID
  name: String
  _dummy_field_: Boolean
}

input CategoryUpdateInput {
  name: String
  posts: [CategoryUpdatePostsEntityRelationInput!]
  _dummy_field_: Boolean
}

input CategoryUpdatePostsEntityRelationInput {
  create: PostWithoutCategoriesCreateInput
  update: CategoryUpdatePostsRelationInput
  upsert: CategoryUpsertPostsRelationInput
  connect: PostUniqueWhere
  disconnect: PostUniqueWhere
  delete: PostUniqueWhere
  alias: String
}

input CategoryUpdatePostsRelationInput {
  by: PostUniqueWhere
  data: PostWithoutCategoriesUpdateInput
}

input PostWithoutCategoriesUpdateInput {
  author: PostUpdateAuthorEntityRelationInput
  publishedAt: DateTime
  locales: [PostUpdateLocalesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostUpdateAuthorEntityRelationInput {
  create: AuthorWithoutPostsCreateInput
  update: AuthorWithoutPostsUpdateInput
  upsert: PostUpsertAuthorRelationInput
  connect: AuthorUniqueWhere
  disconnect: Boolean
  delete: Boolean
}

input AuthorWithoutPostsUpdateInput {
  name: String
  _dummy_field_: Boolean
}

input PostUpsertAuthorRelationInput {
  update: AuthorWithoutPostsUpdateInput
  create: AuthorWithoutPostsCreateInput
}

input CategoryUpsertPostsRelationInput {
  by: PostUniqueWhere
  update: PostWithoutCategoriesUpdateInput
  create: PostWithoutCategoriesCreateInput
}

input PostLocaleCreateInput {
  id: UUID
  title: String
  Post: PostLocaleCreatePostEntityRelationInput
  _dummy_field_: Boolean
}

input PostLocaleCreatePostEntityRelationInput {
  connect: PostUniqueWhere
  create: PostWithoutLocalesCreateInput
}

input PostWithoutLocalesCreateInput {
  author: PostCreateAuthorEntityRelationInput
  id: UUID
  publishedAt: DateTime
  categories: [PostCreateCategoriesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostLocaleUpdateInput {
  title: String
  Post: PostLocaleUpdatePostEntityRelationInput
  _dummy_field_: Boolean
}

input PostLocaleUpdatePostEntityRelationInput {
  create: PostWithoutLocalesCreateInput
  update: PostWithoutLocalesUpdateInput
  upsert: PostLocaleUpsertPostRelationInput
  connect: PostUniqueWhere
  disconnect: Boolean
  delete: Boolean
}

input PostWithoutLocalesUpdateInput {
  author: PostUpdateAuthorEntityRelationInput
  publishedAt: DateTime
  categories: [PostUpdateCategoriesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostLocaleUpsertPostRelationInput {
  update: PostWithoutLocalesUpdateInput
  create: PostWithoutLocalesCreateInput
}

input PostCreateInput {
  author: PostCreateAuthorEntityRelationInput
  id: UUID
  publishedAt: DateTime
  locales: [PostCreateLocalesEntityRelationInput!]
  categories: [PostCreateCategoriesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostUpdateInput {
  author: PostUpdateAuthorEntityRelationInput
  publishedAt: DateTime
  locales: [PostUpdateLocalesEntityRelationInput!]
  categories: [PostUpdateCategoriesEntityRelationInput!]
  _dummy_field_: Boolean
}

type QueryTransaction {
  getAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere): Author
  listAuthor(filter: AuthorWhere, orderBy: [AuthorOrderBy!], offset: Int, limit: Int): [Author!]!
  paginateAuthor(filter: AuthorWhere, orderBy: [AuthorOrderBy!], skip: Int, first: Int): AuthorConnection!
  validateCreateAuthor(data: AuthorCreateInput!): _ValidationResult!
  validateUpdateAuthor(by: AuthorUniqueWhere!, data: AuthorUpdateInput!): _ValidationResult!
  getCategory(by: CategoryUniqueWhere!, filter: CategoryWhere): Category
  listCategory(filter: CategoryWhere, orderBy: [CategoryOrderBy!], offset: Int, limit: Int): [Category!]!
  paginateCategory(filter: CategoryWhere, orderBy: [CategoryOrderBy!], skip: Int, first: Int): CategoryConnection!
  validateCreateCategory(data: CategoryCreateInput!): _ValidationResult!
  validateUpdateCategory(by: CategoryUniqueWhere!, data: CategoryUpdateInput!): _ValidationResult!
  getPostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere): PostLocale
  listPostLocale(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], offset: Int, limit: Int): [PostLocale!]!
  paginatePostLocale(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], skip: Int, first: Int): PostLocaleConnection!
  validateCreatePostLocale(data: PostLocaleCreateInput!): _ValidationResult!
  validateUpdatePostLocale(by: PostLocaleUniqueWhere!, data: PostLocaleUpdateInput!): _ValidationResult!
  getPost(by: PostUniqueWhere!, filter: PostWhere): Post
  listPost(filter: PostWhere, orderBy: [PostOrderBy!], offset: Int, limit: Int): [Post!]!
  paginatePost(filter: PostWhere, orderBy: [PostOrderBy!], skip: Int, first: Int): PostConnection!
  validateCreatePost(data: PostCreateInput!): _ValidationResult!
  validateUpdatePost(by: PostUniqueWhere!, data: PostUpdateInput!): _ValidationResult!
}

type Info {
  description: String
}

type Mutation {
  createAuthor(data: AuthorCreateInput!): AuthorCreateResult!
  deleteAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere): AuthorDeleteResult!
  updateAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere, data: AuthorUpdateInput!): AuthorUpdateResult!
  upsertAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere, update: AuthorUpdateInput!, create: AuthorCreateInput!): AuthorUpsertResult!
  createCategory(data: CategoryCreateInput!): CategoryCreateResult!
  deleteCategory(by: CategoryUniqueWhere!, filter: CategoryWhere): CategoryDeleteResult!
  updateCategory(by: CategoryUniqueWhere!, filter: CategoryWhere, data: CategoryUpdateInput!): CategoryUpdateResult!
  upsertCategory(by: CategoryUniqueWhere!, filter: CategoryWhere, update: CategoryUpdateInput!, create: CategoryCreateInput!): CategoryUpsertResult!
  createPostLocale(data: PostLocaleCreateInput!): PostLocaleCreateResult!
  deletePostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere): PostLocaleDeleteResult!
  updatePostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere, data: PostLocaleUpdateInput!): PostLocaleUpdateResult!
  upsertPostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere, update: PostLocaleUpdateInput!, create: PostLocaleCreateInput!): PostLocaleUpsertResult!
  createPost(data: PostCreateInput!): PostCreateResult!
  deletePost(by: PostUniqueWhere!, filter: PostWhere): PostDeleteResult!
  updatePost(by: PostUniqueWhere!, filter: PostWhere, data: PostUpdateInput!): PostUpdateResult!
  upsertPost(by: PostUniqueWhere!, filter: PostWhere, update: PostUpdateInput!, create: PostCreateInput!): PostUpsertResult!
  transaction(options: MutationTransactionOptions): MutationTransaction!
  query: Query!
}

type AuthorCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Author
  validation: _ValidationResult!
}

interface MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
}

type _MutationError {
  path: [_PathFragment!]! @deprecated(reason: \\"Use \`paths\`.\\")
  paths: [[_PathFragment!]!]!
  type: _MutationErrorType!
  message: String
}

enum _MutationErrorType {
  NotNullConstraintViolation
  UniqueConstraintViolation
  ForeignKeyConstraintViolation
  NotFoundOrDenied
  NonUniqueWhereInput
  InvalidDataInput
  SqlError
}

type AuthorDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Author
}

type AuthorUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Author
  validation: _ValidationResult!
}

type AuthorUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Author
  validation: _ValidationResult!
}

type CategoryCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Category
  validation: _ValidationResult!
}

type CategoryDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Category
}

type CategoryUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Category
  validation: _ValidationResult!
}

type CategoryUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Category
  validation: _ValidationResult!
}

type PostLocaleCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: PostLocale
  validation: _ValidationResult!
}

type PostLocaleDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: PostLocale
}

type PostLocaleUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: PostLocale
  validation: _ValidationResult!
}

type PostLocaleUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: PostLocale
  validation: _ValidationResult!
}

type PostCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Post
  validation: _ValidationResult!
}

type PostDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Post
}

type PostUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Post
  validation: _ValidationResult!
}

type PostUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Post
  validation: _ValidationResult!
}

type MutationTransaction {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  validation: _ValidationResult!
  createAuthor(data: AuthorCreateInput!): AuthorCreateResult!
  deleteAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere): AuthorDeleteResult!
  updateAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere, data: AuthorUpdateInput!): AuthorUpdateResult!
  upsertAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere, update: AuthorUpdateInput!, create: AuthorCreateInput!): AuthorUpsertResult!
  createCategory(data: CategoryCreateInput!): CategoryCreateResult!
  deleteCategory(by: CategoryUniqueWhere!, filter: CategoryWhere): CategoryDeleteResult!
  updateCategory(by: CategoryUniqueWhere!, filter: CategoryWhere, data: CategoryUpdateInput!): CategoryUpdateResult!
  upsertCategory(by: CategoryUniqueWhere!, filter: CategoryWhere, update: CategoryUpdateInput!, create: CategoryCreateInput!): CategoryUpsertResult!
  createPostLocale(data: PostLocaleCreateInput!): PostLocaleCreateResult!
  deletePostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere): PostLocaleDeleteResult!
  updatePostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere, data: PostLocaleUpdateInput!): PostLocaleUpdateResult!
  upsertPostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere, update: PostLocaleUpdateInput!, create: PostLocaleCreateInput!): PostLocaleUpsertResult!
  createPost(data: PostCreateInput!): PostCreateResult!
  deletePost(by: PostUniqueWhere!, filter: PostWhere): PostDeleteResult!
  updatePost(by: PostUniqueWhere!, filter: PostWhere, data: PostUpdateInput!): PostUpdateResult!
  upsertPost(by: PostUniqueWhere!, filter: PostWhere, update: PostUpdateInput!, create: PostCreateInput!): PostUpsertResult!
  query: Query
}

input MutationTransactionOptions {
  deferForeignKeyConstraints: Boolean
}
"
`;

exports[`GraphQL schema builder > has many relation reduction 1`] = `
"type Query {
  getPostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere): PostLocale
  listPostLocale(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], offset: Int, limit: Int): [PostLocale!]!
  paginatePostLocale(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], skip: Int, first: Int): PostLocaleConnection!
  validateCreatePostLocale(data: PostLocaleCreateInput!): _ValidationResult!
  validateUpdatePostLocale(by: PostLocaleUniqueWhere!, data: PostLocaleUpdateInput!): _ValidationResult!
  getPost(by: PostUniqueWhere!, filter: PostWhere): Post
  listPost(filter: PostWhere, orderBy: [PostOrderBy!], offset: Int, limit: Int): [Post!]!
  paginatePost(filter: PostWhere, orderBy: [PostOrderBy!], skip: Int, first: Int): PostConnection!
  validateCreatePost(data: PostCreateInput!): _ValidationResult!
  validateUpdatePost(by: PostUniqueWhere!, data: PostUpdateInput!): _ValidationResult!
  transaction: QueryTransaction
  _info: Info
}

type PostLocale {
  _meta: PostLocaleMeta
  id: UUID!
  locale: String
  title: String
  post(filter: PostWhere): Post
}

type PostLocaleMeta {
  id: FieldMeta
  locale: FieldMeta
  title: FieldMeta
  post: FieldMeta
}

type FieldMeta {
  readable: Boolean
  updatable: Boolean
}

scalar UUID

type Post {
  _meta: PostMeta
  id: UUID!
  publishedAt: DateTime
  locales(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], offset: Int, limit: Int): [PostLocale!]!
  localesByLocale(by: PostLocalesByLocaleUniqueWhere!, filter: PostLocaleWhere): PostLocale
  paginateLocales(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], skip: Int, first: Int): PostLocaleConnection!
}

type PostMeta {
  id: FieldMeta
  publishedAt: FieldMeta
  locales: FieldMeta
}

scalar DateTime

input PostLocaleWhere {
  id: UUIDCondition
  locale: StringCondition
  title: StringCondition
  post: PostWhere
  and: [PostLocaleWhere]
  or: [PostLocaleWhere]
  not: PostLocaleWhere
}

input UUIDCondition {
  and: [UUIDCondition!]
  or: [UUIDCondition!]
  not: UUIDCondition
  null: Boolean
  isNull: Boolean
  eq: UUID
  notEq: UUID
  in: [UUID!]
  notIn: [UUID!]
  lt: UUID
  lte: UUID
  gt: UUID
  gte: UUID
}

input StringCondition {
  and: [StringCondition!]
  or: [StringCondition!]
  not: StringCondition
  null: Boolean
  isNull: Boolean
  eq: String
  notEq: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  containsCI: String
  startsWithCI: String
  endsWithCI: String
}

input PostWhere {
  id: UUIDCondition
  publishedAt: DateTimeCondition
  locales: PostLocaleWhere
  and: [PostWhere]
  or: [PostWhere]
  not: PostWhere
}

input DateTimeCondition {
  and: [DateTimeCondition!]
  or: [DateTimeCondition!]
  not: DateTimeCondition
  null: Boolean
  isNull: Boolean
  eq: DateTime
  notEq: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
}

input PostLocaleOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  locale: OrderDirection
  title: OrderDirection
  post: PostOrderBy
}

enum OrderDirection {
  asc
  desc
  ascNullsFirst
  descNullsLast
}

input PostOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  publishedAt: OrderDirection
}

input PostLocalesByLocaleUniqueWhere {
  locale: String
}

type PostLocaleConnection {
  pageInfo: PageInfo!
  edges: [PostLocaleEdge!]!
}

type PageInfo {
  totalCount: Int!
}

type PostLocaleEdge {
  node: PostLocale!
}

input PostLocaleUniqueWhere {
  id: UUID
  locale: String
  post: PostUniqueWhere
}

input PostUniqueWhere {
  id: UUID
  locales: PostLocaleUniqueWhere
}

type _ValidationResult {
  valid: Boolean!
  errors: [_ValidationError!]!
}

type _ValidationError {
  path: [_PathFragment!]!
  message: _ValidationMessage!
}

union _PathFragment = _FieldPathFragment | _IndexPathFragment

type _FieldPathFragment {
  field: String!
}

type _IndexPathFragment {
  index: Int!
  alias: String
}

type _ValidationMessage {
  text: String!
}

input PostLocaleCreateInput {
  locale: String
  title: String
  post: PostLocaleCreatePostEntityRelationInput
  _dummy_field_: Boolean
}

input PostLocaleCreatePostEntityRelationInput {
  connect: PostUniqueWhere
  create: PostWithoutLocalesCreateInput
}

input PostWithoutLocalesCreateInput {
  publishedAt: DateTime
  _dummy_field_: Boolean
}

input PostLocaleUpdateInput {
  locale: String
  title: String
  post: PostLocaleUpdatePostEntityRelationInput
  _dummy_field_: Boolean
}

input PostLocaleUpdatePostEntityRelationInput {
  create: PostWithoutLocalesCreateInput
  update: PostWithoutLocalesUpdateInput
  upsert: PostLocaleUpsertPostRelationInput
  connect: PostUniqueWhere
  disconnect: Boolean
  delete: Boolean
}

input PostWithoutLocalesUpdateInput {
  publishedAt: DateTime
  _dummy_field_: Boolean
}

input PostLocaleUpsertPostRelationInput {
  update: PostWithoutLocalesUpdateInput
  create: PostWithoutLocalesCreateInput
}

type PostConnection {
  pageInfo: PageInfo!
  edges: [PostEdge!]!
}

type PostEdge {
  node: Post!
}

input PostCreateInput {
  publishedAt: DateTime
  locales: [PostCreateLocalesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostCreateLocalesEntityRelationInput {
  connect: PostLocaleUniqueWhere
  create: PostLocaleWithoutPostCreateInput
  alias: String
}

input PostLocaleWithoutPostCreateInput {
  locale: String
  title: String
  _dummy_field_: Boolean
}

input PostUpdateInput {
  publishedAt: DateTime
  locales: [PostUpdateLocalesEntityRelationInput!]
  _dummy_field_: Boolean
}

input PostUpdateLocalesEntityRelationInput {
  create: PostLocaleWithoutPostCreateInput
  update: PostUpdateLocalesRelationInput
  upsert: PostUpsertLocalesRelationInput
  connect: PostLocaleUniqueWhere
  disconnect: PostLocaleUniqueWhere
  delete: PostLocaleUniqueWhere
  alias: String
}

input PostUpdateLocalesRelationInput {
  by: PostLocaleUniqueWhere
  data: PostLocaleWithoutPostUpdateInput
}

input PostLocaleWithoutPostUpdateInput {
  locale: String
  title: String
  _dummy_field_: Boolean
}

input PostUpsertLocalesRelationInput {
  by: PostLocaleUniqueWhere
  update: PostLocaleWithoutPostUpdateInput
  create: PostLocaleWithoutPostCreateInput
}

type QueryTransaction {
  getPostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere): PostLocale
  listPostLocale(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], offset: Int, limit: Int): [PostLocale!]!
  paginatePostLocale(filter: PostLocaleWhere, orderBy: [PostLocaleOrderBy!], skip: Int, first: Int): PostLocaleConnection!
  validateCreatePostLocale(data: PostLocaleCreateInput!): _ValidationResult!
  validateUpdatePostLocale(by: PostLocaleUniqueWhere!, data: PostLocaleUpdateInput!): _ValidationResult!
  getPost(by: PostUniqueWhere!, filter: PostWhere): Post
  listPost(filter: PostWhere, orderBy: [PostOrderBy!], offset: Int, limit: Int): [Post!]!
  paginatePost(filter: PostWhere, orderBy: [PostOrderBy!], skip: Int, first: Int): PostConnection!
  validateCreatePost(data: PostCreateInput!): _ValidationResult!
  validateUpdatePost(by: PostUniqueWhere!, data: PostUpdateInput!): _ValidationResult!
}

type Info {
  description: String
}

type Mutation {
  createPostLocale(data: PostLocaleCreateInput!): PostLocaleCreateResult!
  deletePostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere): PostLocaleDeleteResult!
  updatePostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere, data: PostLocaleUpdateInput!): PostLocaleUpdateResult!
  upsertPostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere, update: PostLocaleUpdateInput!, create: PostLocaleCreateInput!): PostLocaleUpsertResult!
  createPost(data: PostCreateInput!): PostCreateResult!
  deletePost(by: PostUniqueWhere!, filter: PostWhere): PostDeleteResult!
  updatePost(by: PostUniqueWhere!, filter: PostWhere, data: PostUpdateInput!): PostUpdateResult!
  upsertPost(by: PostUniqueWhere!, filter: PostWhere, update: PostUpdateInput!, create: PostCreateInput!): PostUpsertResult!
  transaction(options: MutationTransactionOptions): MutationTransaction!
  query: Query!
}

type PostLocaleCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: PostLocale
  validation: _ValidationResult!
}

interface MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
}

type _MutationError {
  path: [_PathFragment!]! @deprecated(reason: \\"Use \`paths\`.\\")
  paths: [[_PathFragment!]!]!
  type: _MutationErrorType!
  message: String
}

enum _MutationErrorType {
  NotNullConstraintViolation
  UniqueConstraintViolation
  ForeignKeyConstraintViolation
  NotFoundOrDenied
  NonUniqueWhereInput
  InvalidDataInput
  SqlError
}

type PostLocaleDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: PostLocale
}

type PostLocaleUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: PostLocale
  validation: _ValidationResult!
}

type PostLocaleUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: PostLocale
  validation: _ValidationResult!
}

type PostCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Post
  validation: _ValidationResult!
}

type PostDeleteResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Post
}

type PostUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Post
  validation: _ValidationResult!
}

type PostUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Post
  validation: _ValidationResult!
}

type MutationTransaction {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  validation: _ValidationResult!
  createPostLocale(data: PostLocaleCreateInput!): PostLocaleCreateResult!
  deletePostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere): PostLocaleDeleteResult!
  updatePostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere, data: PostLocaleUpdateInput!): PostLocaleUpdateResult!
  upsertPostLocale(by: PostLocaleUniqueWhere!, filter: PostLocaleWhere, update: PostLocaleUpdateInput!, create: PostLocaleCreateInput!): PostLocaleUpsertResult!
  createPost(data: PostCreateInput!): PostCreateResult!
  deletePost(by: PostUniqueWhere!, filter: PostWhere): PostDeleteResult!
  updatePost(by: PostUniqueWhere!, filter: PostWhere, data: PostUpdateInput!): PostUpdateResult!
  upsertPost(by: PostUniqueWhere!, filter: PostWhere, update: PostUpdateInput!, create: PostCreateInput!): PostUpsertResult!
  query: Query
}

input MutationTransactionOptions {
  deferForeignKeyConstraints: Boolean
}
"
`;

exports[`GraphQL schema builder > restricted access to fields by permissions 1`] = `
"type Query {
  getTest(by: TestUniqueWhere!, filter: TestWhere): Test
  listTest(filter: TestWhere, orderBy: [TestOrderBy!], offset: Int, limit: Int): [Test!]!
  paginateTest(filter: TestWhere, orderBy: [TestOrderBy!], skip: Int, first: Int): TestConnection!
  validateCreateTest(data: TestCreateInput!): _ValidationResult!
  validateUpdateTest(by: TestUniqueWhere!, data: TestUpdateInput!): _ValidationResult!
  transaction: QueryTransaction
  _info: Info
}

type Test {
  _meta: TestMeta
  id: UUID!
  c: String
}

type TestMeta {
  id: FieldMeta
  c: FieldMeta
}

type FieldMeta {
  readable: Boolean
  updatable: Boolean
}

scalar UUID

input TestUniqueWhere {
  id: UUID
}

input TestWhere {
  id: UUIDCondition
  c: StringCondition
  and: [TestWhere]
  or: [TestWhere]
  not: TestWhere
}

input UUIDCondition {
  and: [UUIDCondition!]
  or: [UUIDCondition!]
  not: UUIDCondition
  null: Boolean
  isNull: Boolean
  eq: UUID
  notEq: UUID
  in: [UUID!]
  notIn: [UUID!]
  lt: UUID
  lte: UUID
  gt: UUID
  gte: UUID
}

input StringCondition {
  and: [StringCondition!]
  or: [StringCondition!]
  not: StringCondition
  null: Boolean
  isNull: Boolean
  eq: String
  notEq: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  containsCI: String
  startsWithCI: String
  endsWithCI: String
}

input TestOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  c: OrderDirection
}

enum OrderDirection {
  asc
  desc
  ascNullsFirst
  descNullsLast
}

type TestConnection {
  pageInfo: PageInfo!
  edges: [TestEdge!]!
}

type PageInfo {
  totalCount: Int!
}

type TestEdge {
  node: Test!
}

type _ValidationResult {
  valid: Boolean!
  errors: [_ValidationError!]!
}

type _ValidationError {
  path: [_PathFragment!]!
  message: _ValidationMessage!
}

union _PathFragment = _FieldPathFragment | _IndexPathFragment

type _FieldPathFragment {
  field: String!
}

type _IndexPathFragment {
  index: Int!
  alias: String
}

type _ValidationMessage {
  text: String!
}

input TestCreateInput {
  a: String
  _dummy_field_: Boolean
}

input TestUpdateInput {
  b: String
  _dummy_field_: Boolean
}

type QueryTransaction {
  getTest(by: TestUniqueWhere!, filter: TestWhere): Test
  listTest(filter: TestWhere, orderBy: [TestOrderBy!], offset: Int, limit: Int): [Test!]!
  paginateTest(filter: TestWhere, orderBy: [TestOrderBy!], skip: Int, first: Int): TestConnection!
  validateCreateTest(data: TestCreateInput!): _ValidationResult!
  validateUpdateTest(by: TestUniqueWhere!, data: TestUpdateInput!): _ValidationResult!
}

type Info {
  description: String
}

type Mutation {
  createTest(data: TestCreateInput!): TestCreateResult!
  updateTest(by: TestUniqueWhere!, filter: TestWhere, data: TestUpdateInput!): TestUpdateResult!
  upsertTest(by: TestUniqueWhere!, filter: TestWhere, update: TestUpdateInput!, create: TestCreateInput!): TestUpsertResult!
  transaction(options: MutationTransactionOptions): MutationTransaction!
  query: Query!
}

type TestCreateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Test
  validation: _ValidationResult!
}

interface MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
}

type _MutationError {
  path: [_PathFragment!]! @deprecated(reason: \\"Use \`paths\`.\\")
  paths: [[_PathFragment!]!]!
  type: _MutationErrorType!
  message: String
}

enum _MutationErrorType {
  NotNullConstraintViolation
  UniqueConstraintViolation
  ForeignKeyConstraintViolation
  NotFoundOrDenied
  NonUniqueWhereInput
  InvalidDataInput
  SqlError
}

type TestUpdateResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Test
  validation: _ValidationResult!
}

type TestUpsertResult implements MutationResult {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  node: Test
  validation: _ValidationResult!
}

type MutationTransaction {
  ok: Boolean!
  errorMessage: String
  errors: [_MutationError!]!
  validation: _ValidationResult!
  createTest(data: TestCreateInput!): TestCreateResult!
  updateTest(by: TestUniqueWhere!, filter: TestWhere, data: TestUpdateInput!): TestUpdateResult!
  upsertTest(by: TestUniqueWhere!, filter: TestWhere, update: TestUpdateInput!, create: TestCreateInput!): TestUpsertResult!
  query: Query
}

input MutationTransactionOptions {
  deferForeignKeyConstraints: Boolean
}
"
`;

exports[`GraphQL schema builder > view entity 1`] = `
"type Query {
  getAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere): Author
  listAuthor(filter: AuthorWhere, orderBy: [AuthorOrderBy!], offset: Int, limit: Int): [Author!]!
  paginateAuthor(filter: AuthorWhere, orderBy: [AuthorOrderBy!], skip: Int, first: Int): AuthorConnection!
  transaction: QueryTransaction
  _info: Info
}

type Author {
  _meta: AuthorMeta
  id: UUID!
  name: String
}

type AuthorMeta {
  id: FieldMeta
  name: FieldMeta
}

type FieldMeta {
  readable: Boolean
  updatable: Boolean
}

scalar UUID

input AuthorUniqueWhere {
  id: UUID
}

input AuthorWhere {
  id: UUIDCondition
  name: StringCondition
  and: [AuthorWhere]
  or: [AuthorWhere]
  not: AuthorWhere
}

input UUIDCondition {
  and: [UUIDCondition!]
  or: [UUIDCondition!]
  not: UUIDCondition
  null: Boolean
  isNull: Boolean
  eq: UUID
  notEq: UUID
  in: [UUID!]
  notIn: [UUID!]
  lt: UUID
  lte: UUID
  gt: UUID
  gte: UUID
}

input StringCondition {
  and: [StringCondition!]
  or: [StringCondition!]
  not: StringCondition
  null: Boolean
  isNull: Boolean
  eq: String
  notEq: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  containsCI: String
  startsWithCI: String
  endsWithCI: String
}

input AuthorOrderBy {
  _random: Boolean
  _randomSeeded: Int
  id: OrderDirection
  name: OrderDirection
}

enum OrderDirection {
  asc
  desc
  ascNullsFirst
  descNullsLast
}

type AuthorConnection {
  pageInfo: PageInfo!
  edges: [AuthorEdge!]!
}

type PageInfo {
  totalCount: Int!
}

type AuthorEdge {
  node: Author!
}

type QueryTransaction {
  getAuthor(by: AuthorUniqueWhere!, filter: AuthorWhere): Author
  listAuthor(filter: AuthorWhere, orderBy: [AuthorOrderBy!], offset: Int, limit: Int): [Author!]!
  paginateAuthor(filter: AuthorWhere, orderBy: [AuthorOrderBy!], skip: Int, first: Int): AuthorConnection!
}

type Info {
  description: String
}
"
`;
